/* soapC.cpp
   Generated by gSOAP 2.8.4 from OLSWS.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.4 2011-11-24 18:00:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns3__DataHolder:
		return soap_in_ns3__DataHolder(soap, NULL, NULL, "ns3:DataHolder");
	case SOAP_TYPE_ns2__Vector:
		return soap_in_ns2__Vector(soap, NULL, NULL, "ns2:Vector");
	case SOAP_TYPE_ns2__Map:
		return soap_in_ns2__Map(soap, NULL, NULL, "ns2:Map");
	case SOAP_TYPE_ns2__mapItem:
		return soap_in_ns2__mapItem(soap, NULL, NULL, "ns2:mapItem");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationDataResponse:
		return soap_in_PointerTo_ns1__getTermsByAnnotationDataResponse(soap, NULL, NULL, "ns1:getTermsByAnnotationDataResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationData:
		return soap_in_PointerTo_ns1__getTermsByAnnotationData(soap, NULL, NULL, "ns1:getTermsByAnnotationData");
	case SOAP_TYPE_PointerTo_ns1__isObsoleteResponse:
		return soap_in_PointerTo_ns1__isObsoleteResponse(soap, NULL, NULL, "ns1:isObsoleteResponse");
	case SOAP_TYPE_PointerTo_ns1__isObsolete:
		return soap_in_PointerTo_ns1__isObsolete(soap, NULL, NULL, "ns1:isObsolete");
	case SOAP_TYPE_PointerTo_ns1__getChildrenFromRootResponse:
		return soap_in_PointerTo_ns1__getChildrenFromRootResponse(soap, NULL, NULL, "ns1:getChildrenFromRootResponse");
	case SOAP_TYPE_PointerTo_ns1__getChildrenFromRoot:
		return soap_in_PointerTo_ns1__getChildrenFromRoot(soap, NULL, NULL, "ns1:getChildrenFromRoot");
	case SOAP_TYPE_PointerTo_ns1__getTermRelationsResponse:
		return soap_in_PointerTo_ns1__getTermRelationsResponse(soap, NULL, NULL, "ns1:getTermRelationsResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermRelations:
		return soap_in_PointerTo_ns1__getTermRelations(soap, NULL, NULL, "ns1:getTermRelations");
	case SOAP_TYPE_PointerTo_ns1__getTermChildrenResponse:
		return soap_in_PointerTo_ns1__getTermChildrenResponse(soap, NULL, NULL, "ns1:getTermChildrenResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermChildren:
		return soap_in_PointerTo_ns1__getTermChildren(soap, NULL, NULL, "ns1:getTermChildren");
	case SOAP_TYPE_PointerTo_ns1__getTermParentsResponse:
		return soap_in_PointerTo_ns1__getTermParentsResponse(soap, NULL, NULL, "ns1:getTermParentsResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermParents:
		return soap_in_PointerTo_ns1__getTermParents(soap, NULL, NULL, "ns1:getTermParents");
	case SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByNameResponse:
		return soap_in_PointerTo_ns1__getPrefixedTermsByNameResponse(soap, NULL, NULL, "ns1:getPrefixedTermsByNameResponse");
	case SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByName:
		return soap_in_PointerTo_ns1__getPrefixedTermsByName(soap, NULL, NULL, "ns1:getPrefixedTermsByName");
	case SOAP_TYPE_PointerTo_ns1__getTermsByExactNameResponse:
		return soap_in_PointerTo_ns1__getTermsByExactNameResponse(soap, NULL, NULL, "ns1:getTermsByExactNameResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermsByExactName:
		return soap_in_PointerTo_ns1__getTermsByExactName(soap, NULL, NULL, "ns1:getTermsByExactName");
	case SOAP_TYPE_PointerTo_ns1__getTermsByNameResponse:
		return soap_in_PointerTo_ns1__getTermsByNameResponse(soap, NULL, NULL, "ns1:getTermsByNameResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermsByName:
		return soap_in_PointerTo_ns1__getTermsByName(soap, NULL, NULL, "ns1:getTermsByName");
	case SOAP_TYPE_PointerTo_ns1__getRootTermsResponse:
		return soap_in_PointerTo_ns1__getRootTermsResponse(soap, NULL, NULL, "ns1:getRootTermsResponse");
	case SOAP_TYPE_PointerTo_ns1__getRootTerms:
		return soap_in_PointerTo_ns1__getRootTerms(soap, NULL, NULL, "ns1:getRootTerms");
	case SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntologyResponse:
		return soap_in_PointerTo_ns1__getAllTermsFromOntologyResponse(soap, NULL, NULL, "ns1:getAllTermsFromOntologyResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntology:
		return soap_in_PointerTo_ns1__getAllTermsFromOntology(soap, NULL, NULL, "ns1:getAllTermsFromOntology");
	case SOAP_TYPE_PointerTo_ns1__getOntologyLoadDateResponse:
		return soap_in_PointerTo_ns1__getOntologyLoadDateResponse(soap, NULL, NULL, "ns1:getOntologyLoadDateResponse");
	case SOAP_TYPE_PointerTo_ns1__getOntologyLoadDate:
		return soap_in_PointerTo_ns1__getOntologyLoadDate(soap, NULL, NULL, "ns1:getOntologyLoadDate");
	case SOAP_TYPE_PointerTo_ns1__getOntologyNamesResponse:
		return soap_in_PointerTo_ns1__getOntologyNamesResponse(soap, NULL, NULL, "ns1:getOntologyNamesResponse");
	case SOAP_TYPE_PointerTo_ns1__getOntologyNames:
		return soap_in_PointerTo_ns1__getOntologyNames(soap, NULL, NULL, "ns1:getOntologyNames");
	case SOAP_TYPE_PointerTo_ns1__getTermXrefsResponse:
		return soap_in_PointerTo_ns1__getTermXrefsResponse(soap, NULL, NULL, "ns1:getTermXrefsResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermXrefs:
		return soap_in_PointerTo_ns1__getTermXrefs(soap, NULL, NULL, "ns1:getTermXrefs");
	case SOAP_TYPE_PointerTo_ns1__getTermMetadataResponse:
		return soap_in_PointerTo_ns1__getTermMetadataResponse(soap, NULL, NULL, "ns1:getTermMetadataResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermMetadata:
		return soap_in_PointerTo_ns1__getTermMetadata(soap, NULL, NULL, "ns1:getTermMetadata");
	case SOAP_TYPE_PointerTo_ns1__getTermByIdResponse:
		return soap_in_PointerTo_ns1__getTermByIdResponse(soap, NULL, NULL, "ns1:getTermByIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermById:
		return soap_in_PointerTo_ns1__getTermById(soap, NULL, NULL, "ns1:getTermById");
	case SOAP_TYPE_PointerTo_ns1__getVersionResponse:
		return soap_in_PointerTo_ns1__getVersionResponse(soap, NULL, NULL, "ns1:getVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__getVersion:
		return soap_in_PointerTo_ns1__getVersion(soap, NULL, NULL, "ns1:getVersion");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTons2__mapItem:
		return soap_in_PointerTons2__mapItem(soap, NULL, NULL, "ns2:mapItem");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTons3__DataHolder:
		return soap_in_PointerTons3__DataHolder(soap, NULL, NULL, "ns3:DataHolder");
	case SOAP_TYPE_PointerTons2__Vector:
		return soap_in_PointerTons2__Vector(soap, NULL, NULL, "ns2:Vector");
	case SOAP_TYPE_PointerTons2__Map:
		return soap_in_PointerTons2__Map(soap, NULL, NULL, "ns2:Map");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:DataHolder"))
		{	*type = SOAP_TYPE_ns3__DataHolder;
			return soap_in_ns3__DataHolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Vector"))
		{	*type = SOAP_TYPE_ns2__Vector;
			return soap_in_ns2__Vector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Map"))
		{	*type = SOAP_TYPE_ns2__Map;
			return soap_in_ns2__Map(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:mapItem"))
		{	*type = SOAP_TYPE_ns2__mapItem;
			return soap_in_ns2__mapItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:getTermsByAnnotationDataResponse"))
		{	*type = SOAP_TYPE__ns1__getTermsByAnnotationDataResponse;
			return soap_in__ns1__getTermsByAnnotationDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermsByAnnotationData"))
		{	*type = SOAP_TYPE__ns1__getTermsByAnnotationData;
			return soap_in__ns1__getTermsByAnnotationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:isObsoleteResponse"))
		{	*type = SOAP_TYPE__ns1__isObsoleteResponse;
			return soap_in__ns1__isObsoleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:isObsolete"))
		{	*type = SOAP_TYPE__ns1__isObsolete;
			return soap_in__ns1__isObsolete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChildrenFromRootResponse"))
		{	*type = SOAP_TYPE__ns1__getChildrenFromRootResponse;
			return soap_in__ns1__getChildrenFromRootResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChildrenFromRoot"))
		{	*type = SOAP_TYPE__ns1__getChildrenFromRoot;
			return soap_in__ns1__getChildrenFromRoot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermRelationsResponse"))
		{	*type = SOAP_TYPE__ns1__getTermRelationsResponse;
			return soap_in__ns1__getTermRelationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermRelations"))
		{	*type = SOAP_TYPE__ns1__getTermRelations;
			return soap_in__ns1__getTermRelations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermChildrenResponse"))
		{	*type = SOAP_TYPE__ns1__getTermChildrenResponse;
			return soap_in__ns1__getTermChildrenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermChildren"))
		{	*type = SOAP_TYPE__ns1__getTermChildren;
			return soap_in__ns1__getTermChildren(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermParentsResponse"))
		{	*type = SOAP_TYPE__ns1__getTermParentsResponse;
			return soap_in__ns1__getTermParentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermParents"))
		{	*type = SOAP_TYPE__ns1__getTermParents;
			return soap_in__ns1__getTermParents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrefixedTermsByNameResponse"))
		{	*type = SOAP_TYPE__ns1__getPrefixedTermsByNameResponse;
			return soap_in__ns1__getPrefixedTermsByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrefixedTermsByName"))
		{	*type = SOAP_TYPE__ns1__getPrefixedTermsByName;
			return soap_in__ns1__getPrefixedTermsByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermsByExactNameResponse"))
		{	*type = SOAP_TYPE__ns1__getTermsByExactNameResponse;
			return soap_in__ns1__getTermsByExactNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermsByExactName"))
		{	*type = SOAP_TYPE__ns1__getTermsByExactName;
			return soap_in__ns1__getTermsByExactName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermsByNameResponse"))
		{	*type = SOAP_TYPE__ns1__getTermsByNameResponse;
			return soap_in__ns1__getTermsByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermsByName"))
		{	*type = SOAP_TYPE__ns1__getTermsByName;
			return soap_in__ns1__getTermsByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRootTermsResponse"))
		{	*type = SOAP_TYPE__ns1__getRootTermsResponse;
			return soap_in__ns1__getRootTermsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRootTerms"))
		{	*type = SOAP_TYPE__ns1__getRootTerms;
			return soap_in__ns1__getRootTerms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllTermsFromOntologyResponse"))
		{	*type = SOAP_TYPE__ns1__getAllTermsFromOntologyResponse;
			return soap_in__ns1__getAllTermsFromOntologyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllTermsFromOntology"))
		{	*type = SOAP_TYPE__ns1__getAllTermsFromOntology;
			return soap_in__ns1__getAllTermsFromOntology(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOntologyLoadDateResponse"))
		{	*type = SOAP_TYPE__ns1__getOntologyLoadDateResponse;
			return soap_in__ns1__getOntologyLoadDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOntologyLoadDate"))
		{	*type = SOAP_TYPE__ns1__getOntologyLoadDate;
			return soap_in__ns1__getOntologyLoadDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOntologyNamesResponse"))
		{	*type = SOAP_TYPE__ns1__getOntologyNamesResponse;
			return soap_in__ns1__getOntologyNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOntologyNames"))
		{	*type = SOAP_TYPE__ns1__getOntologyNames;
			return soap_in__ns1__getOntologyNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermXrefsResponse"))
		{	*type = SOAP_TYPE__ns1__getTermXrefsResponse;
			return soap_in__ns1__getTermXrefsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermXrefs"))
		{	*type = SOAP_TYPE__ns1__getTermXrefs;
			return soap_in__ns1__getTermXrefs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermMetadataResponse"))
		{	*type = SOAP_TYPE__ns1__getTermMetadataResponse;
			return soap_in__ns1__getTermMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermMetadata"))
		{	*type = SOAP_TYPE__ns1__getTermMetadata;
			return soap_in__ns1__getTermMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermByIdResponse"))
		{	*type = SOAP_TYPE__ns1__getTermByIdResponse;
			return soap_in__ns1__getTermByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTermById"))
		{	*type = SOAP_TYPE__ns1__getTermById;
			return soap_in__ns1__getTermById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVersionResponse"))
		{	*type = SOAP_TYPE__ns1__getVersionResponse;
			return soap_in__ns1__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVersion"))
		{	*type = SOAP_TYPE__ns1__getVersion;
			return soap_in__ns1__getVersion(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns3__DataHolder:
		return ((ns3__DataHolder *)ptr)->soap_out(soap, tag, id, "ns3:DataHolder");
	case SOAP_TYPE_ns2__Vector:
		return ((ns2__Vector *)ptr)->soap_out(soap, tag, id, "ns2:Vector");
	case SOAP_TYPE_ns2__Map:
		return ((ns2__Map *)ptr)->soap_out(soap, tag, id, "ns2:Map");
	case SOAP_TYPE_ns2__mapItem:
		return ((ns2__mapItem *)ptr)->soap_out(soap, tag, id, "ns2:mapItem");
	case SOAP_TYPE__ns1__getTermsByAnnotationDataResponse:
		return ((_ns1__getTermsByAnnotationDataResponse *)ptr)->soap_out(soap, "ns1:getTermsByAnnotationDataResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermsByAnnotationData:
		return ((_ns1__getTermsByAnnotationData *)ptr)->soap_out(soap, "ns1:getTermsByAnnotationData", id, NULL);
	case SOAP_TYPE__ns1__isObsoleteResponse:
		return ((_ns1__isObsoleteResponse *)ptr)->soap_out(soap, "ns1:isObsoleteResponse", id, NULL);
	case SOAP_TYPE__ns1__isObsolete:
		return ((_ns1__isObsolete *)ptr)->soap_out(soap, "ns1:isObsolete", id, NULL);
	case SOAP_TYPE__ns1__getChildrenFromRootResponse:
		return ((_ns1__getChildrenFromRootResponse *)ptr)->soap_out(soap, "ns1:getChildrenFromRootResponse", id, NULL);
	case SOAP_TYPE__ns1__getChildrenFromRoot:
		return ((_ns1__getChildrenFromRoot *)ptr)->soap_out(soap, "ns1:getChildrenFromRoot", id, NULL);
	case SOAP_TYPE__ns1__getTermRelationsResponse:
		return ((_ns1__getTermRelationsResponse *)ptr)->soap_out(soap, "ns1:getTermRelationsResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermRelations:
		return ((_ns1__getTermRelations *)ptr)->soap_out(soap, "ns1:getTermRelations", id, NULL);
	case SOAP_TYPE__ns1__getTermChildrenResponse:
		return ((_ns1__getTermChildrenResponse *)ptr)->soap_out(soap, "ns1:getTermChildrenResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermChildren:
		return ((_ns1__getTermChildren *)ptr)->soap_out(soap, "ns1:getTermChildren", id, NULL);
	case SOAP_TYPE__ns1__getTermParentsResponse:
		return ((_ns1__getTermParentsResponse *)ptr)->soap_out(soap, "ns1:getTermParentsResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermParents:
		return ((_ns1__getTermParents *)ptr)->soap_out(soap, "ns1:getTermParents", id, NULL);
	case SOAP_TYPE__ns1__getPrefixedTermsByNameResponse:
		return ((_ns1__getPrefixedTermsByNameResponse *)ptr)->soap_out(soap, "ns1:getPrefixedTermsByNameResponse", id, NULL);
	case SOAP_TYPE__ns1__getPrefixedTermsByName:
		return ((_ns1__getPrefixedTermsByName *)ptr)->soap_out(soap, "ns1:getPrefixedTermsByName", id, NULL);
	case SOAP_TYPE__ns1__getTermsByExactNameResponse:
		return ((_ns1__getTermsByExactNameResponse *)ptr)->soap_out(soap, "ns1:getTermsByExactNameResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermsByExactName:
		return ((_ns1__getTermsByExactName *)ptr)->soap_out(soap, "ns1:getTermsByExactName", id, NULL);
	case SOAP_TYPE__ns1__getTermsByNameResponse:
		return ((_ns1__getTermsByNameResponse *)ptr)->soap_out(soap, "ns1:getTermsByNameResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermsByName:
		return ((_ns1__getTermsByName *)ptr)->soap_out(soap, "ns1:getTermsByName", id, NULL);
	case SOAP_TYPE__ns1__getRootTermsResponse:
		return ((_ns1__getRootTermsResponse *)ptr)->soap_out(soap, "ns1:getRootTermsResponse", id, NULL);
	case SOAP_TYPE__ns1__getRootTerms:
		return ((_ns1__getRootTerms *)ptr)->soap_out(soap, "ns1:getRootTerms", id, NULL);
	case SOAP_TYPE__ns1__getAllTermsFromOntologyResponse:
		return ((_ns1__getAllTermsFromOntologyResponse *)ptr)->soap_out(soap, "ns1:getAllTermsFromOntologyResponse", id, NULL);
	case SOAP_TYPE__ns1__getAllTermsFromOntology:
		return ((_ns1__getAllTermsFromOntology *)ptr)->soap_out(soap, "ns1:getAllTermsFromOntology", id, NULL);
	case SOAP_TYPE__ns1__getOntologyLoadDateResponse:
		return ((_ns1__getOntologyLoadDateResponse *)ptr)->soap_out(soap, "ns1:getOntologyLoadDateResponse", id, NULL);
	case SOAP_TYPE__ns1__getOntologyLoadDate:
		return ((_ns1__getOntologyLoadDate *)ptr)->soap_out(soap, "ns1:getOntologyLoadDate", id, NULL);
	case SOAP_TYPE__ns1__getOntologyNamesResponse:
		return ((_ns1__getOntologyNamesResponse *)ptr)->soap_out(soap, "ns1:getOntologyNamesResponse", id, NULL);
	case SOAP_TYPE__ns1__getOntologyNames:
		return ((_ns1__getOntologyNames *)ptr)->soap_out(soap, "ns1:getOntologyNames", id, NULL);
	case SOAP_TYPE__ns1__getTermXrefsResponse:
		return ((_ns1__getTermXrefsResponse *)ptr)->soap_out(soap, "ns1:getTermXrefsResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermXrefs:
		return ((_ns1__getTermXrefs *)ptr)->soap_out(soap, "ns1:getTermXrefs", id, NULL);
	case SOAP_TYPE__ns1__getTermMetadataResponse:
		return ((_ns1__getTermMetadataResponse *)ptr)->soap_out(soap, "ns1:getTermMetadataResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermMetadata:
		return ((_ns1__getTermMetadata *)ptr)->soap_out(soap, "ns1:getTermMetadata", id, NULL);
	case SOAP_TYPE__ns1__getTermByIdResponse:
		return ((_ns1__getTermByIdResponse *)ptr)->soap_out(soap, "ns1:getTermByIdResponse", id, NULL);
	case SOAP_TYPE__ns1__getTermById:
		return ((_ns1__getTermById *)ptr)->soap_out(soap, "ns1:getTermById", id, NULL);
	case SOAP_TYPE__ns1__getVersionResponse:
		return ((_ns1__getVersionResponse *)ptr)->soap_out(soap, "ns1:getVersionResponse", id, NULL);
	case SOAP_TYPE__ns1__getVersion:
		return ((_ns1__getVersion *)ptr)->soap_out(soap, "ns1:getVersion", id, NULL);
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationDataResponse:
		return soap_out_PointerTo_ns1__getTermsByAnnotationDataResponse(soap, tag, id, (_ns1__getTermsByAnnotationDataResponse *const*)ptr, "ns1:getTermsByAnnotationDataResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationData:
		return soap_out_PointerTo_ns1__getTermsByAnnotationData(soap, tag, id, (_ns1__getTermsByAnnotationData *const*)ptr, "ns1:getTermsByAnnotationData");
	case SOAP_TYPE_PointerTo_ns1__isObsoleteResponse:
		return soap_out_PointerTo_ns1__isObsoleteResponse(soap, tag, id, (_ns1__isObsoleteResponse *const*)ptr, "ns1:isObsoleteResponse");
	case SOAP_TYPE_PointerTo_ns1__isObsolete:
		return soap_out_PointerTo_ns1__isObsolete(soap, tag, id, (_ns1__isObsolete *const*)ptr, "ns1:isObsolete");
	case SOAP_TYPE_PointerTo_ns1__getChildrenFromRootResponse:
		return soap_out_PointerTo_ns1__getChildrenFromRootResponse(soap, tag, id, (_ns1__getChildrenFromRootResponse *const*)ptr, "ns1:getChildrenFromRootResponse");
	case SOAP_TYPE_PointerTo_ns1__getChildrenFromRoot:
		return soap_out_PointerTo_ns1__getChildrenFromRoot(soap, tag, id, (_ns1__getChildrenFromRoot *const*)ptr, "ns1:getChildrenFromRoot");
	case SOAP_TYPE_PointerTo_ns1__getTermRelationsResponse:
		return soap_out_PointerTo_ns1__getTermRelationsResponse(soap, tag, id, (_ns1__getTermRelationsResponse *const*)ptr, "ns1:getTermRelationsResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermRelations:
		return soap_out_PointerTo_ns1__getTermRelations(soap, tag, id, (_ns1__getTermRelations *const*)ptr, "ns1:getTermRelations");
	case SOAP_TYPE_PointerTo_ns1__getTermChildrenResponse:
		return soap_out_PointerTo_ns1__getTermChildrenResponse(soap, tag, id, (_ns1__getTermChildrenResponse *const*)ptr, "ns1:getTermChildrenResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermChildren:
		return soap_out_PointerTo_ns1__getTermChildren(soap, tag, id, (_ns1__getTermChildren *const*)ptr, "ns1:getTermChildren");
	case SOAP_TYPE_PointerTo_ns1__getTermParentsResponse:
		return soap_out_PointerTo_ns1__getTermParentsResponse(soap, tag, id, (_ns1__getTermParentsResponse *const*)ptr, "ns1:getTermParentsResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermParents:
		return soap_out_PointerTo_ns1__getTermParents(soap, tag, id, (_ns1__getTermParents *const*)ptr, "ns1:getTermParents");
	case SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByNameResponse:
		return soap_out_PointerTo_ns1__getPrefixedTermsByNameResponse(soap, tag, id, (_ns1__getPrefixedTermsByNameResponse *const*)ptr, "ns1:getPrefixedTermsByNameResponse");
	case SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByName:
		return soap_out_PointerTo_ns1__getPrefixedTermsByName(soap, tag, id, (_ns1__getPrefixedTermsByName *const*)ptr, "ns1:getPrefixedTermsByName");
	case SOAP_TYPE_PointerTo_ns1__getTermsByExactNameResponse:
		return soap_out_PointerTo_ns1__getTermsByExactNameResponse(soap, tag, id, (_ns1__getTermsByExactNameResponse *const*)ptr, "ns1:getTermsByExactNameResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermsByExactName:
		return soap_out_PointerTo_ns1__getTermsByExactName(soap, tag, id, (_ns1__getTermsByExactName *const*)ptr, "ns1:getTermsByExactName");
	case SOAP_TYPE_PointerTo_ns1__getTermsByNameResponse:
		return soap_out_PointerTo_ns1__getTermsByNameResponse(soap, tag, id, (_ns1__getTermsByNameResponse *const*)ptr, "ns1:getTermsByNameResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermsByName:
		return soap_out_PointerTo_ns1__getTermsByName(soap, tag, id, (_ns1__getTermsByName *const*)ptr, "ns1:getTermsByName");
	case SOAP_TYPE_PointerTo_ns1__getRootTermsResponse:
		return soap_out_PointerTo_ns1__getRootTermsResponse(soap, tag, id, (_ns1__getRootTermsResponse *const*)ptr, "ns1:getRootTermsResponse");
	case SOAP_TYPE_PointerTo_ns1__getRootTerms:
		return soap_out_PointerTo_ns1__getRootTerms(soap, tag, id, (_ns1__getRootTerms *const*)ptr, "ns1:getRootTerms");
	case SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntologyResponse:
		return soap_out_PointerTo_ns1__getAllTermsFromOntologyResponse(soap, tag, id, (_ns1__getAllTermsFromOntologyResponse *const*)ptr, "ns1:getAllTermsFromOntologyResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntology:
		return soap_out_PointerTo_ns1__getAllTermsFromOntology(soap, tag, id, (_ns1__getAllTermsFromOntology *const*)ptr, "ns1:getAllTermsFromOntology");
	case SOAP_TYPE_PointerTo_ns1__getOntologyLoadDateResponse:
		return soap_out_PointerTo_ns1__getOntologyLoadDateResponse(soap, tag, id, (_ns1__getOntologyLoadDateResponse *const*)ptr, "ns1:getOntologyLoadDateResponse");
	case SOAP_TYPE_PointerTo_ns1__getOntologyLoadDate:
		return soap_out_PointerTo_ns1__getOntologyLoadDate(soap, tag, id, (_ns1__getOntologyLoadDate *const*)ptr, "ns1:getOntologyLoadDate");
	case SOAP_TYPE_PointerTo_ns1__getOntologyNamesResponse:
		return soap_out_PointerTo_ns1__getOntologyNamesResponse(soap, tag, id, (_ns1__getOntologyNamesResponse *const*)ptr, "ns1:getOntologyNamesResponse");
	case SOAP_TYPE_PointerTo_ns1__getOntologyNames:
		return soap_out_PointerTo_ns1__getOntologyNames(soap, tag, id, (_ns1__getOntologyNames *const*)ptr, "ns1:getOntologyNames");
	case SOAP_TYPE_PointerTo_ns1__getTermXrefsResponse:
		return soap_out_PointerTo_ns1__getTermXrefsResponse(soap, tag, id, (_ns1__getTermXrefsResponse *const*)ptr, "ns1:getTermXrefsResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermXrefs:
		return soap_out_PointerTo_ns1__getTermXrefs(soap, tag, id, (_ns1__getTermXrefs *const*)ptr, "ns1:getTermXrefs");
	case SOAP_TYPE_PointerTo_ns1__getTermMetadataResponse:
		return soap_out_PointerTo_ns1__getTermMetadataResponse(soap, tag, id, (_ns1__getTermMetadataResponse *const*)ptr, "ns1:getTermMetadataResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermMetadata:
		return soap_out_PointerTo_ns1__getTermMetadata(soap, tag, id, (_ns1__getTermMetadata *const*)ptr, "ns1:getTermMetadata");
	case SOAP_TYPE_PointerTo_ns1__getTermByIdResponse:
		return soap_out_PointerTo_ns1__getTermByIdResponse(soap, tag, id, (_ns1__getTermByIdResponse *const*)ptr, "ns1:getTermByIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getTermById:
		return soap_out_PointerTo_ns1__getTermById(soap, tag, id, (_ns1__getTermById *const*)ptr, "ns1:getTermById");
	case SOAP_TYPE_PointerTo_ns1__getVersionResponse:
		return soap_out_PointerTo_ns1__getVersionResponse(soap, tag, id, (_ns1__getVersionResponse *const*)ptr, "ns1:getVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__getVersion:
		return soap_out_PointerTo_ns1__getVersion(soap, tag, id, (_ns1__getVersion *const*)ptr, "ns1:getVersion");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTons2__mapItem:
		return soap_out_PointerTons2__mapItem(soap, tag, id, (ns2__mapItem *const*)ptr, "ns2:mapItem");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTons3__DataHolder:
		return soap_out_PointerTons3__DataHolder(soap, tag, id, (ns3__DataHolder *const*)ptr, "ns3:DataHolder");
	case SOAP_TYPE_PointerTons2__Vector:
		return soap_out_PointerTons2__Vector(soap, tag, id, (ns2__Vector *const*)ptr, "ns2:Vector");
	case SOAP_TYPE_PointerTons2__Map:
		return soap_out_PointerTons2__Map(soap, tag, id, (ns2__Map *const*)ptr, "ns2:Map");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns3__DataHolder:
		((ns3__DataHolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Vector:
		((ns2__Vector *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Map:
		((ns2__Map *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__mapItem:
		((ns2__mapItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermsByAnnotationDataResponse:
		((_ns1__getTermsByAnnotationDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermsByAnnotationData:
		((_ns1__getTermsByAnnotationData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__isObsoleteResponse:
		((_ns1__isObsoleteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__isObsolete:
		((_ns1__isObsolete *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getChildrenFromRootResponse:
		((_ns1__getChildrenFromRootResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getChildrenFromRoot:
		((_ns1__getChildrenFromRoot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermRelationsResponse:
		((_ns1__getTermRelationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermRelations:
		((_ns1__getTermRelations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermChildrenResponse:
		((_ns1__getTermChildrenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermChildren:
		((_ns1__getTermChildren *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermParentsResponse:
		((_ns1__getTermParentsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermParents:
		((_ns1__getTermParents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPrefixedTermsByNameResponse:
		((_ns1__getPrefixedTermsByNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPrefixedTermsByName:
		((_ns1__getPrefixedTermsByName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermsByExactNameResponse:
		((_ns1__getTermsByExactNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermsByExactName:
		((_ns1__getTermsByExactName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermsByNameResponse:
		((_ns1__getTermsByNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermsByName:
		((_ns1__getTermsByName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRootTermsResponse:
		((_ns1__getRootTermsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRootTerms:
		((_ns1__getRootTerms *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllTermsFromOntologyResponse:
		((_ns1__getAllTermsFromOntologyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAllTermsFromOntology:
		((_ns1__getAllTermsFromOntology *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getOntologyLoadDateResponse:
		((_ns1__getOntologyLoadDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getOntologyLoadDate:
		((_ns1__getOntologyLoadDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getOntologyNamesResponse:
		((_ns1__getOntologyNamesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getOntologyNames:
		((_ns1__getOntologyNames *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermXrefsResponse:
		((_ns1__getTermXrefsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermXrefs:
		((_ns1__getTermXrefs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermMetadataResponse:
		((_ns1__getTermMetadataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermMetadata:
		((_ns1__getTermMetadata *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermByIdResponse:
		((_ns1__getTermByIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTermById:
		((_ns1__getTermById *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getVersionResponse:
		((_ns1__getVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getVersion:
		((_ns1__getVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getTermsByAnnotationData:
		soap_serialize___ns1__getTermsByAnnotationData(soap, (const struct __ns1__getTermsByAnnotationData *)ptr);
		break;
	case SOAP_TYPE___ns1__isObsolete:
		soap_serialize___ns1__isObsolete(soap, (const struct __ns1__isObsolete *)ptr);
		break;
	case SOAP_TYPE___ns1__getChildrenFromRoot:
		soap_serialize___ns1__getChildrenFromRoot(soap, (const struct __ns1__getChildrenFromRoot *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermRelations:
		soap_serialize___ns1__getTermRelations(soap, (const struct __ns1__getTermRelations *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermChildren:
		soap_serialize___ns1__getTermChildren(soap, (const struct __ns1__getTermChildren *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermParents:
		soap_serialize___ns1__getTermParents(soap, (const struct __ns1__getTermParents *)ptr);
		break;
	case SOAP_TYPE___ns1__getPrefixedTermsByName:
		soap_serialize___ns1__getPrefixedTermsByName(soap, (const struct __ns1__getPrefixedTermsByName *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermsByExactName:
		soap_serialize___ns1__getTermsByExactName(soap, (const struct __ns1__getTermsByExactName *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermsByName:
		soap_serialize___ns1__getTermsByName(soap, (const struct __ns1__getTermsByName *)ptr);
		break;
	case SOAP_TYPE___ns1__getRootTerms:
		soap_serialize___ns1__getRootTerms(soap, (const struct __ns1__getRootTerms *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllTermsFromOntology:
		soap_serialize___ns1__getAllTermsFromOntology(soap, (const struct __ns1__getAllTermsFromOntology *)ptr);
		break;
	case SOAP_TYPE___ns1__getOntologyLoadDate:
		soap_serialize___ns1__getOntologyLoadDate(soap, (const struct __ns1__getOntologyLoadDate *)ptr);
		break;
	case SOAP_TYPE___ns1__getOntologyNames:
		soap_serialize___ns1__getOntologyNames(soap, (const struct __ns1__getOntologyNames *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermXrefs:
		soap_serialize___ns1__getTermXrefs(soap, (const struct __ns1__getTermXrefs *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermMetadata:
		soap_serialize___ns1__getTermMetadata(soap, (const struct __ns1__getTermMetadata *)ptr);
		break;
	case SOAP_TYPE___ns1__getTermById:
		soap_serialize___ns1__getTermById(soap, (const struct __ns1__getTermById *)ptr);
		break;
	case SOAP_TYPE___ns1__getVersion:
		soap_serialize___ns1__getVersion(soap, (const struct __ns1__getVersion *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationDataResponse:
		soap_serialize_PointerTo_ns1__getTermsByAnnotationDataResponse(soap, (_ns1__getTermsByAnnotationDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationData:
		soap_serialize_PointerTo_ns1__getTermsByAnnotationData(soap, (_ns1__getTermsByAnnotationData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__isObsoleteResponse:
		soap_serialize_PointerTo_ns1__isObsoleteResponse(soap, (_ns1__isObsoleteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__isObsolete:
		soap_serialize_PointerTo_ns1__isObsolete(soap, (_ns1__isObsolete *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChildrenFromRootResponse:
		soap_serialize_PointerTo_ns1__getChildrenFromRootResponse(soap, (_ns1__getChildrenFromRootResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChildrenFromRoot:
		soap_serialize_PointerTo_ns1__getChildrenFromRoot(soap, (_ns1__getChildrenFromRoot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermRelationsResponse:
		soap_serialize_PointerTo_ns1__getTermRelationsResponse(soap, (_ns1__getTermRelationsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermRelations:
		soap_serialize_PointerTo_ns1__getTermRelations(soap, (_ns1__getTermRelations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermChildrenResponse:
		soap_serialize_PointerTo_ns1__getTermChildrenResponse(soap, (_ns1__getTermChildrenResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermChildren:
		soap_serialize_PointerTo_ns1__getTermChildren(soap, (_ns1__getTermChildren *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermParentsResponse:
		soap_serialize_PointerTo_ns1__getTermParentsResponse(soap, (_ns1__getTermParentsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermParents:
		soap_serialize_PointerTo_ns1__getTermParents(soap, (_ns1__getTermParents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByNameResponse:
		soap_serialize_PointerTo_ns1__getPrefixedTermsByNameResponse(soap, (_ns1__getPrefixedTermsByNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByName:
		soap_serialize_PointerTo_ns1__getPrefixedTermsByName(soap, (_ns1__getPrefixedTermsByName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermsByExactNameResponse:
		soap_serialize_PointerTo_ns1__getTermsByExactNameResponse(soap, (_ns1__getTermsByExactNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermsByExactName:
		soap_serialize_PointerTo_ns1__getTermsByExactName(soap, (_ns1__getTermsByExactName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermsByNameResponse:
		soap_serialize_PointerTo_ns1__getTermsByNameResponse(soap, (_ns1__getTermsByNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermsByName:
		soap_serialize_PointerTo_ns1__getTermsByName(soap, (_ns1__getTermsByName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRootTermsResponse:
		soap_serialize_PointerTo_ns1__getRootTermsResponse(soap, (_ns1__getRootTermsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRootTerms:
		soap_serialize_PointerTo_ns1__getRootTerms(soap, (_ns1__getRootTerms *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntologyResponse:
		soap_serialize_PointerTo_ns1__getAllTermsFromOntologyResponse(soap, (_ns1__getAllTermsFromOntologyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntology:
		soap_serialize_PointerTo_ns1__getAllTermsFromOntology(soap, (_ns1__getAllTermsFromOntology *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOntologyLoadDateResponse:
		soap_serialize_PointerTo_ns1__getOntologyLoadDateResponse(soap, (_ns1__getOntologyLoadDateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOntologyLoadDate:
		soap_serialize_PointerTo_ns1__getOntologyLoadDate(soap, (_ns1__getOntologyLoadDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOntologyNamesResponse:
		soap_serialize_PointerTo_ns1__getOntologyNamesResponse(soap, (_ns1__getOntologyNamesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOntologyNames:
		soap_serialize_PointerTo_ns1__getOntologyNames(soap, (_ns1__getOntologyNames *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermXrefsResponse:
		soap_serialize_PointerTo_ns1__getTermXrefsResponse(soap, (_ns1__getTermXrefsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermXrefs:
		soap_serialize_PointerTo_ns1__getTermXrefs(soap, (_ns1__getTermXrefs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermMetadataResponse:
		soap_serialize_PointerTo_ns1__getTermMetadataResponse(soap, (_ns1__getTermMetadataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermMetadata:
		soap_serialize_PointerTo_ns1__getTermMetadata(soap, (_ns1__getTermMetadata *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermByIdResponse:
		soap_serialize_PointerTo_ns1__getTermByIdResponse(soap, (_ns1__getTermByIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTermById:
		soap_serialize_PointerTo_ns1__getTermById(soap, (_ns1__getTermById *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVersionResponse:
		soap_serialize_PointerTo_ns1__getVersionResponse(soap, (_ns1__getVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVersion:
		soap_serialize_PointerTo_ns1__getVersion(soap, (_ns1__getVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__mapItem:
		soap_serialize_PointerTons2__mapItem(soap, (ns2__mapItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__DataHolder:
		soap_serialize_PointerTons3__DataHolder(soap, (ns3__DataHolder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Vector:
		soap_serialize_PointerTons2__Vector(soap, (ns2__Vector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Map:
		soap_serialize_PointerTons2__Map(soap, (ns2__Map *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getVersion:
		return (void*)soap_instantiate__ns1__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getVersionResponse:
		return (void*)soap_instantiate__ns1__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermById:
		return (void*)soap_instantiate__ns1__getTermById(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermByIdResponse:
		return (void*)soap_instantiate__ns1__getTermByIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermMetadata:
		return (void*)soap_instantiate__ns1__getTermMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermMetadataResponse:
		return (void*)soap_instantiate__ns1__getTermMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermXrefs:
		return (void*)soap_instantiate__ns1__getTermXrefs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermXrefsResponse:
		return (void*)soap_instantiate__ns1__getTermXrefsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getOntologyNames:
		return (void*)soap_instantiate__ns1__getOntologyNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getOntologyNamesResponse:
		return (void*)soap_instantiate__ns1__getOntologyNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getOntologyLoadDate:
		return (void*)soap_instantiate__ns1__getOntologyLoadDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getOntologyLoadDateResponse:
		return (void*)soap_instantiate__ns1__getOntologyLoadDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllTermsFromOntology:
		return (void*)soap_instantiate__ns1__getAllTermsFromOntology(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAllTermsFromOntologyResponse:
		return (void*)soap_instantiate__ns1__getAllTermsFromOntologyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRootTerms:
		return (void*)soap_instantiate__ns1__getRootTerms(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRootTermsResponse:
		return (void*)soap_instantiate__ns1__getRootTermsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermsByName:
		return (void*)soap_instantiate__ns1__getTermsByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermsByNameResponse:
		return (void*)soap_instantiate__ns1__getTermsByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermsByExactName:
		return (void*)soap_instantiate__ns1__getTermsByExactName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermsByExactNameResponse:
		return (void*)soap_instantiate__ns1__getTermsByExactNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPrefixedTermsByName:
		return (void*)soap_instantiate__ns1__getPrefixedTermsByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPrefixedTermsByNameResponse:
		return (void*)soap_instantiate__ns1__getPrefixedTermsByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermParents:
		return (void*)soap_instantiate__ns1__getTermParents(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermParentsResponse:
		return (void*)soap_instantiate__ns1__getTermParentsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermChildren:
		return (void*)soap_instantiate__ns1__getTermChildren(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermChildrenResponse:
		return (void*)soap_instantiate__ns1__getTermChildrenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermRelations:
		return (void*)soap_instantiate__ns1__getTermRelations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermRelationsResponse:
		return (void*)soap_instantiate__ns1__getTermRelationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getChildrenFromRoot:
		return (void*)soap_instantiate__ns1__getChildrenFromRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getChildrenFromRootResponse:
		return (void*)soap_instantiate__ns1__getChildrenFromRootResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__isObsolete:
		return (void*)soap_instantiate__ns1__isObsolete(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__isObsoleteResponse:
		return (void*)soap_instantiate__ns1__isObsoleteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermsByAnnotationData:
		return (void*)soap_instantiate__ns1__getTermsByAnnotationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTermsByAnnotationDataResponse:
		return (void*)soap_instantiate__ns1__getTermsByAnnotationDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__mapItem:
		return (void*)soap_instantiate_ns2__mapItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Map:
		return (void*)soap_instantiate_ns2__Map(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Vector:
		return (void*)soap_instantiate_ns2__Vector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__DataHolder:
		return (void*)soap_instantiate_ns3__DataHolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getVersion:
		return (void*)soap_instantiate___ns1__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermById:
		return (void*)soap_instantiate___ns1__getTermById(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermMetadata:
		return (void*)soap_instantiate___ns1__getTermMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermXrefs:
		return (void*)soap_instantiate___ns1__getTermXrefs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getOntologyNames:
		return (void*)soap_instantiate___ns1__getOntologyNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getOntologyLoadDate:
		return (void*)soap_instantiate___ns1__getOntologyLoadDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAllTermsFromOntology:
		return (void*)soap_instantiate___ns1__getAllTermsFromOntology(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRootTerms:
		return (void*)soap_instantiate___ns1__getRootTerms(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermsByName:
		return (void*)soap_instantiate___ns1__getTermsByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermsByExactName:
		return (void*)soap_instantiate___ns1__getTermsByExactName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPrefixedTermsByName:
		return (void*)soap_instantiate___ns1__getPrefixedTermsByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermParents:
		return (void*)soap_instantiate___ns1__getTermParents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermChildren:
		return (void*)soap_instantiate___ns1__getTermChildren(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermRelations:
		return (void*)soap_instantiate___ns1__getTermRelations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getChildrenFromRoot:
		return (void*)soap_instantiate___ns1__getChildrenFromRoot(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isObsolete:
		return (void*)soap_instantiate___ns1__isObsolete(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTermsByAnnotationData:
		return (void*)soap_instantiate___ns1__getTermsByAnnotationData(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__mapItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__mapItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DataHolder:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__DataHolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((xsd__anyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__anyType*)p->ptr);
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			SOAP_DELETE((xsd__boolean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__boolean*)p->ptr);
		break;
	case SOAP_TYPE_xsd__double:
		if (p->size < 0)
			SOAP_DELETE((xsd__double*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__double*)p->ptr);
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			SOAP_DELETE((xsd__int*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__int*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE((xsd__string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__string*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getVersion:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getVersion*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermById:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermById*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermById*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermByIdResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermByIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermByIdResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermMetadata:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermMetadata*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermMetadataResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermMetadataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermMetadataResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermXrefs:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermXrefs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermXrefs*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermXrefsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermXrefsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermXrefsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getOntologyNames:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getOntologyNames*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getOntologyNames*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getOntologyNamesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getOntologyNamesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getOntologyNamesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getOntologyLoadDate:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getOntologyLoadDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getOntologyLoadDate*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getOntologyLoadDateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getOntologyLoadDateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getOntologyLoadDateResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllTermsFromOntology:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllTermsFromOntology*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllTermsFromOntology*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAllTermsFromOntologyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAllTermsFromOntologyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAllTermsFromOntologyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getRootTerms:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getRootTerms*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getRootTerms*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getRootTermsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getRootTermsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getRootTermsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermsByName:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermsByName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermsByName*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermsByNameResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermsByNameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermsByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermsByExactName:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermsByExactName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermsByExactName*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermsByExactNameResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermsByExactNameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermsByExactNameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getPrefixedTermsByName:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getPrefixedTermsByName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getPrefixedTermsByName*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getPrefixedTermsByNameResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getPrefixedTermsByNameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getPrefixedTermsByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermParents:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermParents*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermParents*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermParentsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermParentsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermParentsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermChildren:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermChildren*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermChildren*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermChildrenResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermChildrenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermChildrenResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermRelations:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermRelations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermRelations*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermRelationsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermRelationsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermRelationsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getChildrenFromRoot:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getChildrenFromRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getChildrenFromRoot*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getChildrenFromRootResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getChildrenFromRootResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getChildrenFromRootResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__isObsolete:
		if (p->size < 0)
			SOAP_DELETE((_ns1__isObsolete*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__isObsolete*)p->ptr);
		break;
	case SOAP_TYPE__ns1__isObsoleteResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__isObsoleteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__isObsoleteResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermsByAnnotationData:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermsByAnnotationData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermsByAnnotationData*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTermsByAnnotationDataResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTermsByAnnotationDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTermsByAnnotationDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__mapItem:
		if (p->size < 0)
			SOAP_DELETE((ns2__mapItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__mapItem*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Map:
		if (p->size < 0)
			SOAP_DELETE((ns2__Map*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Map*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Vector:
		if (p->size < 0)
			SOAP_DELETE((ns2__Vector*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Vector*)p->ptr);
		break;
	case SOAP_TYPE_ns3__DataHolder:
		if (p->size < 0)
			SOAP_DELETE((ns3__DataHolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__DataHolder*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getVersion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getVersion*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermById:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermById*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermById*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermMetadata:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermMetadata*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermXrefs:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermXrefs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermXrefs*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getOntologyNames:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getOntologyNames*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getOntologyNames*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getOntologyLoadDate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getOntologyLoadDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getOntologyLoadDate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAllTermsFromOntology:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAllTermsFromOntology*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAllTermsFromOntology*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getRootTerms:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getRootTerms*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getRootTerms*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermsByName:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermsByName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermsByName*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermsByExactName:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermsByExactName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermsByExactName*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPrefixedTermsByName:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPrefixedTermsByName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPrefixedTermsByName*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermParents:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermParents*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermParents*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermChildren:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermChildren*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermChildren*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermRelations:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermRelations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermRelations*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getChildrenFromRoot:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getChildrenFromRoot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getChildrenFromRoot*)p->ptr);
		break;
	case SOAP_TYPE___ns1__isObsolete:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__isObsolete*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__isObsolete*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTermsByAnnotationData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTermsByAnnotationData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTermsByAnnotationData*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<xsd__anyType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<xsd__anyType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__mapItem:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__mapItem * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__mapItem * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DataHolder:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__DataHolder * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__DataHolder * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			SOAP_DELETE((std::vector<int >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<int >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<xsd__anyType * >*)p)[len] = *(xsd__anyType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__mapItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__mapItem * >*)p)[len] = *(ns2__mapItem **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__DataHolder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__DataHolder * >*)p)[len] = *(ns3__DataHolder **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__DataHolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__DataHolder::annotationNumberValue = NULL;
	this->ns3__DataHolder::annotationStringValue = NULL;
	this->ns3__DataHolder::annotationType = NULL;
	this->ns3__DataHolder::termId = NULL;
	this->ns3__DataHolder::termName = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns3__DataHolder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns3__DataHolder::annotationNumberValue);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DataHolder::annotationStringValue);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DataHolder::annotationType);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DataHolder::termId);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DataHolder::termName);
	/* transient soap skipped */
}

int ns3__DataHolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DataHolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DataHolder(struct soap *soap, const char *tag, int id, const ns3__DataHolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__DataHolder), "ns3:DataHolder"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns3:annotationNumberValue", -1, &(a->ns3__DataHolder::annotationNumberValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:annotationStringValue", -1, &(a->ns3__DataHolder::annotationStringValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:annotationType", -1, &(a->ns3__DataHolder::annotationType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:termId", -1, &(a->ns3__DataHolder::termId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:termName", -1, &(a->ns3__DataHolder::termName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__DataHolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__DataHolder(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DataHolder * SOAP_FMAC4 soap_in_ns3__DataHolder(struct soap *soap, const char *tag, ns3__DataHolder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DataHolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__DataHolder, sizeof(ns3__DataHolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__DataHolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DataHolder *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_annotationNumberValue1 = 1;
	size_t soap_flag_annotationStringValue1 = 1;
	size_t soap_flag_annotationType1 = 1;
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_termName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_annotationNumberValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns3:annotationNumberValue", &(a->ns3__DataHolder::annotationNumberValue), "xsd:double"))
				{	soap_flag_annotationNumberValue1--;
					continue;
				}
			if (soap_flag_annotationStringValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:annotationStringValue", &(a->ns3__DataHolder::annotationStringValue), "xsd:string"))
				{	soap_flag_annotationStringValue1--;
					continue;
				}
			if (soap_flag_annotationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:annotationType", &(a->ns3__DataHolder::annotationType), "xsd:string"))
				{	soap_flag_annotationType1--;
					continue;
				}
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:termId", &(a->ns3__DataHolder::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_termName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:termName", &(a->ns3__DataHolder::termName), "xsd:string"))
				{	soap_flag_termName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DataHolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__DataHolder, 0, sizeof(ns3__DataHolder), 0, soap_copy_ns3__DataHolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__DataHolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__DataHolder);
	if (this->soap_out(soap, tag?tag:"ns3:DataHolder", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DataHolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DataHolder(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DataHolder * SOAP_FMAC4 soap_get_ns3__DataHolder(struct soap *soap, ns3__DataHolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DataHolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__DataHolder * SOAP_FMAC2 soap_instantiate_ns3__DataHolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DataHolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__DataHolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__DataHolder);
		if (size)
			*size = sizeof(ns3__DataHolder);
		((ns3__DataHolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__DataHolder[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__DataHolder);
		for (int i = 0; i < n; i++)
			((ns3__DataHolder*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__DataHolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DataHolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DataHolder %p -> %p\n", q, p));
	*(ns3__DataHolder*)p = *(ns3__DataHolder*)q;
}

void ns2__Vector::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns2__Vector::item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns2__Vector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns2__Vector::item);
	/* transient soap skipped */
}

int ns2__Vector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Vector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Vector(struct soap *soap, const char *tag, int id, const ns2__Vector *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Vector), "ns2:Vector"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerToxsd__anyType(soap, "ns2:item", -1, &(a->ns2__Vector::item), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Vector::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Vector(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Vector * SOAP_FMAC4 soap_in_ns2__Vector(struct soap *soap, const char *tag, ns2__Vector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Vector *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Vector, sizeof(ns2__Vector), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Vector)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Vector *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToxsd__anyType(soap, "ns2:item", &(a->ns2__Vector::item), "xsd:anyType"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Vector, 0, sizeof(ns2__Vector), 0, soap_copy_ns2__Vector);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Vector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Vector);
	if (this->soap_out(soap, tag?tag:"ns2:Vector", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Vector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Vector(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Vector * SOAP_FMAC4 soap_get_ns2__Vector(struct soap *soap, ns2__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Vector * SOAP_FMAC2 soap_instantiate_ns2__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Vector(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Vector, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Vector);
		if (size)
			*size = sizeof(ns2__Vector);
		((ns2__Vector*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__Vector[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__Vector);
		for (int i = 0; i < n; i++)
			((ns2__Vector*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__Vector*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Vector(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Vector %p -> %p\n", q, p));
	*(ns2__Vector*)p = *(ns2__Vector*)q;
}

void ns2__Map::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__mapItem(soap, &this->ns2__Map::item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns2__Map::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__mapItem(soap, &this->ns2__Map::item);
	/* transient soap skipped */
}

int ns2__Map::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Map(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Map(struct soap *soap, const char *tag, int id, const ns2__Map *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Map), "ns2:Map"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__mapItem(soap, "ns2:item", -1, &(a->ns2__Map::item), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Map::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Map(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Map * SOAP_FMAC4 soap_in_ns2__Map(struct soap *soap, const char *tag, ns2__Map *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Map *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Map, sizeof(ns2__Map), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Map)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Map *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__mapItem(soap, "ns2:item", &(a->ns2__Map::item), "ns2:mapItem"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Map *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Map, 0, sizeof(ns2__Map), 0, soap_copy_ns2__Map);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Map::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Map);
	if (this->soap_out(soap, tag?tag:"ns2:Map", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Map::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Map(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Map * SOAP_FMAC4 soap_get_ns2__Map(struct soap *soap, ns2__Map *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Map * SOAP_FMAC2 soap_instantiate_ns2__Map(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Map(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Map, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Map);
		if (size)
			*size = sizeof(ns2__Map);
		((ns2__Map*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__Map[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__Map);
		for (int i = 0; i < n; i++)
			((ns2__Map*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__Map*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Map(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Map %p -> %p\n", q, p));
	*(ns2__Map*)p = *(ns2__Map*)q;
}

void ns2__mapItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__mapItem::key = NULL;
	this->ns2__mapItem::value = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns2__mapItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &this->ns2__mapItem::key);
	soap_serialize_PointerToxsd__anyType(soap, &this->ns2__mapItem::value);
	/* transient soap skipped */
}

int ns2__mapItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__mapItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__mapItem(struct soap *soap, const char *tag, int id, const ns2__mapItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__mapItem), "ns2:mapItem"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__anyType(soap, "ns2:key", -1, &(a->ns2__mapItem::key), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "ns2:value", -1, &(a->ns2__mapItem::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__mapItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__mapItem(soap, tag, this, type);
}

SOAP_FMAC3 ns2__mapItem * SOAP_FMAC4 soap_in_ns2__mapItem(struct soap *soap, const char *tag, ns2__mapItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__mapItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__mapItem, sizeof(ns2__mapItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__mapItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__mapItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_key1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns2:key", &(a->ns2__mapItem::key), "xsd:anyType"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns2:value", &(a->ns2__mapItem::value), "xsd:anyType"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__mapItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__mapItem, 0, sizeof(ns2__mapItem), 0, soap_copy_ns2__mapItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__mapItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__mapItem);
	if (this->soap_out(soap, tag?tag:"ns2:mapItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__mapItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__mapItem(soap, this, tag, type);
}

SOAP_FMAC3 ns2__mapItem * SOAP_FMAC4 soap_get_ns2__mapItem(struct soap *soap, ns2__mapItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__mapItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__mapItem * SOAP_FMAC2 soap_instantiate_ns2__mapItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__mapItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__mapItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__mapItem);
		if (size)
			*size = sizeof(ns2__mapItem);
		((ns2__mapItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__mapItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__mapItem);
		for (int i = 0; i < n; i++)
			((ns2__mapItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__mapItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__mapItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__mapItem %p -> %p\n", q, p));
	*(ns2__mapItem*)p = *(ns2__mapItem*)q;
}

void _ns1__getTermsByAnnotationDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__DataHolder(soap, &this->_ns1__getTermsByAnnotationDataResponse::getTermsByAnnotationDataReturn);
	/* transient soap skipped */
}

void _ns1__getTermsByAnnotationDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__DataHolder(soap, &this->_ns1__getTermsByAnnotationDataResponse::getTermsByAnnotationDataReturn);
	/* transient soap skipped */
}

int _ns1__getTermsByAnnotationDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermsByAnnotationDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermsByAnnotationDataResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermsByAnnotationDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:getTermsByAnnotationDataReturn");
	if (soap_out_std__vectorTemplateOfPointerTons3__DataHolder(soap, "ns1:getTermsByAnnotationDataReturn", -1, &(a->_ns1__getTermsByAnnotationDataResponse::getTermsByAnnotationDataReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermsByAnnotationDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermsByAnnotationDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationDataResponse * SOAP_FMAC4 soap_in__ns1__getTermsByAnnotationDataResponse(struct soap *soap, const char *tag, _ns1__getTermsByAnnotationDataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermsByAnnotationDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse, sizeof(_ns1__getTermsByAnnotationDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermsByAnnotationDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermsByAnnotationDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__DataHolder(soap, "ns1:getTermsByAnnotationDataReturn", &(a->_ns1__getTermsByAnnotationDataResponse::getTermsByAnnotationDataReturn), "ns3:DataHolder"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermsByAnnotationDataReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermsByAnnotationDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse, 0, sizeof(_ns1__getTermsByAnnotationDataResponse), 0, soap_copy__ns1__getTermsByAnnotationDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getTermsByAnnotationDataResponse::getTermsByAnnotationDataReturn.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermsByAnnotationDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermsByAnnotationDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermsByAnnotationDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermsByAnnotationDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationDataResponse * SOAP_FMAC4 soap_get__ns1__getTermsByAnnotationDataResponse(struct soap *soap, _ns1__getTermsByAnnotationDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermsByAnnotationDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermsByAnnotationDataResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermsByAnnotationDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermsByAnnotationDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByAnnotationDataResponse);
		if (size)
			*size = sizeof(_ns1__getTermsByAnnotationDataResponse);
		((_ns1__getTermsByAnnotationDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByAnnotationDataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermsByAnnotationDataResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermsByAnnotationDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermsByAnnotationDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermsByAnnotationDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermsByAnnotationDataResponse %p -> %p\n", q, p));
	*(_ns1__getTermsByAnnotationDataResponse*)p = *(_ns1__getTermsByAnnotationDataResponse*)q;
}

void _ns1__getTermsByAnnotationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermsByAnnotationData::ontologyName);
	soap_default_std__string(soap, &this->_ns1__getTermsByAnnotationData::annotationType);
	soap_default_std__string(soap, &this->_ns1__getTermsByAnnotationData::strValue);
	soap_default_double(soap, &this->_ns1__getTermsByAnnotationData::fromDblValue);
	soap_default_double(soap, &this->_ns1__getTermsByAnnotationData::toDblValue);
	/* transient soap skipped */
}

void _ns1__getTermsByAnnotationData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermsByAnnotationData::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermsByAnnotationData::ontologyName);
	soap_embedded(soap, &this->_ns1__getTermsByAnnotationData::annotationType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermsByAnnotationData::annotationType);
	soap_embedded(soap, &this->_ns1__getTermsByAnnotationData::strValue, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermsByAnnotationData::strValue);
	soap_embedded(soap, &this->_ns1__getTermsByAnnotationData::fromDblValue, SOAP_TYPE_double);
	soap_embedded(soap, &this->_ns1__getTermsByAnnotationData::toDblValue, SOAP_TYPE_double);
	/* transient soap skipped */
}

int _ns1__getTermsByAnnotationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermsByAnnotationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermsByAnnotationData(struct soap *soap, const char *tag, int id, const _ns1__getTermsByAnnotationData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermsByAnnotationData), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermsByAnnotationData::ontologyName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:annotationType", -1, &(a->_ns1__getTermsByAnnotationData::annotationType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:strValue", -1, &(a->_ns1__getTermsByAnnotationData::strValue), ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:fromDblValue", -1, &(a->_ns1__getTermsByAnnotationData::fromDblValue), ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:toDblValue", -1, &(a->_ns1__getTermsByAnnotationData::toDblValue), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermsByAnnotationData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermsByAnnotationData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationData * SOAP_FMAC4 soap_in__ns1__getTermsByAnnotationData(struct soap *soap, const char *tag, _ns1__getTermsByAnnotationData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermsByAnnotationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermsByAnnotationData, sizeof(_ns1__getTermsByAnnotationData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermsByAnnotationData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermsByAnnotationData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ontologyName1 = 1;
	size_t soap_flag_annotationType1 = 1;
	size_t soap_flag_strValue1 = 1;
	size_t soap_flag_fromDblValue1 = 1;
	size_t soap_flag_toDblValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermsByAnnotationData::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			if (soap_flag_annotationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:annotationType", &(a->_ns1__getTermsByAnnotationData::annotationType), "xsd:string"))
				{	soap_flag_annotationType1--;
					continue;
				}
			if (soap_flag_strValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:strValue", &(a->_ns1__getTermsByAnnotationData::strValue), "xsd:string"))
				{	soap_flag_strValue1--;
					continue;
				}
			if (soap_flag_fromDblValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:fromDblValue", &(a->_ns1__getTermsByAnnotationData::fromDblValue), "xsd:double"))
				{	soap_flag_fromDblValue1--;
					continue;
				}
			if (soap_flag_toDblValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:toDblValue", &(a->_ns1__getTermsByAnnotationData::toDblValue), "xsd:double"))
				{	soap_flag_toDblValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermsByAnnotationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermsByAnnotationData, 0, sizeof(_ns1__getTermsByAnnotationData), 0, soap_copy__ns1__getTermsByAnnotationData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ontologyName1 > 0 || soap_flag_annotationType1 > 0 || soap_flag_strValue1 > 0 || soap_flag_fromDblValue1 > 0 || soap_flag_toDblValue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermsByAnnotationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermsByAnnotationData);
	if (this->soap_out(soap, tag?tag:"ns1:getTermsByAnnotationData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermsByAnnotationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermsByAnnotationData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationData * SOAP_FMAC4 soap_get__ns1__getTermsByAnnotationData(struct soap *soap, _ns1__getTermsByAnnotationData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermsByAnnotationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermsByAnnotationData * SOAP_FMAC2 soap_instantiate__ns1__getTermsByAnnotationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermsByAnnotationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermsByAnnotationData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByAnnotationData);
		if (size)
			*size = sizeof(_ns1__getTermsByAnnotationData);
		((_ns1__getTermsByAnnotationData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByAnnotationData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermsByAnnotationData);
		for (int i = 0; i < n; i++)
			((_ns1__getTermsByAnnotationData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermsByAnnotationData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermsByAnnotationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermsByAnnotationData %p -> %p\n", q, p));
	*(_ns1__getTermsByAnnotationData*)p = *(_ns1__getTermsByAnnotationData*)q;
}

void _ns1__isObsoleteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__isObsoleteResponse::isObsoleteReturn);
	/* transient soap skipped */
}

void _ns1__isObsoleteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__isObsoleteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__isObsoleteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__isObsoleteResponse(struct soap *soap, const char *tag, int id, const _ns1__isObsoleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__isObsoleteResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:isObsoleteReturn");
	if (soap_out_bool(soap, "ns1:isObsoleteReturn", -1, &(a->_ns1__isObsoleteResponse::isObsoleteReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__isObsoleteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__isObsoleteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__isObsoleteResponse * SOAP_FMAC4 soap_in__ns1__isObsoleteResponse(struct soap *soap, const char *tag, _ns1__isObsoleteResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__isObsoleteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__isObsoleteResponse, sizeof(_ns1__isObsoleteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__isObsoleteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__isObsoleteResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_isObsoleteReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isObsoleteReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isObsoleteReturn", &(a->_ns1__isObsoleteResponse::isObsoleteReturn), "xsd:boolean"))
				{	soap_flag_isObsoleteReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:isObsoleteReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__isObsoleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__isObsoleteResponse, 0, sizeof(_ns1__isObsoleteResponse), 0, soap_copy__ns1__isObsoleteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isObsoleteReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__isObsoleteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__isObsoleteResponse);
	if (this->soap_out(soap, tag?tag:"ns1:isObsoleteResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__isObsoleteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__isObsoleteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__isObsoleteResponse * SOAP_FMAC4 soap_get__ns1__isObsoleteResponse(struct soap *soap, _ns1__isObsoleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__isObsoleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__isObsoleteResponse * SOAP_FMAC2 soap_instantiate__ns1__isObsoleteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__isObsoleteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__isObsoleteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__isObsoleteResponse);
		if (size)
			*size = sizeof(_ns1__isObsoleteResponse);
		((_ns1__isObsoleteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__isObsoleteResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__isObsoleteResponse);
		for (int i = 0; i < n; i++)
			((_ns1__isObsoleteResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__isObsoleteResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__isObsoleteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__isObsoleteResponse %p -> %p\n", q, p));
	*(_ns1__isObsoleteResponse*)p = *(_ns1__isObsoleteResponse*)q;
}

void _ns1__isObsolete::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__isObsolete::termId);
	soap_default_std__string(soap, &this->_ns1__isObsolete::ontologyName);
	/* transient soap skipped */
}

void _ns1__isObsolete::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__isObsolete::termId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__isObsolete::termId);
	soap_embedded(soap, &this->_ns1__isObsolete::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__isObsolete::ontologyName);
	/* transient soap skipped */
}

int _ns1__isObsolete::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__isObsolete(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__isObsolete(struct soap *soap, const char *tag, int id, const _ns1__isObsolete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__isObsolete), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:termId", -1, &(a->_ns1__isObsolete::termId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__isObsolete::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__isObsolete::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__isObsolete(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__isObsolete * SOAP_FMAC4 soap_in__ns1__isObsolete(struct soap *soap, const char *tag, _ns1__isObsolete *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__isObsolete *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__isObsolete, sizeof(_ns1__isObsolete), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__isObsolete)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__isObsolete *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:termId", &(a->_ns1__isObsolete::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__isObsolete::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__isObsolete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__isObsolete, 0, sizeof(_ns1__isObsolete), 0, soap_copy__ns1__isObsolete);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId1 > 0 || soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__isObsolete::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__isObsolete);
	if (this->soap_out(soap, tag?tag:"ns1:isObsolete", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__isObsolete::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__isObsolete(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__isObsolete * SOAP_FMAC4 soap_get__ns1__isObsolete(struct soap *soap, _ns1__isObsolete *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__isObsolete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__isObsolete * SOAP_FMAC2 soap_instantiate__ns1__isObsolete(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__isObsolete(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__isObsolete, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__isObsolete);
		if (size)
			*size = sizeof(_ns1__isObsolete);
		((_ns1__isObsolete*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__isObsolete[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__isObsolete);
		for (int i = 0; i < n; i++)
			((_ns1__isObsolete*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__isObsolete*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__isObsolete(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__isObsolete %p -> %p\n", q, p));
	*(_ns1__isObsolete*)p = *(_ns1__isObsolete*)q;
}

void _ns1__getChildrenFromRootResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getChildrenFromRootResponse::getChildrenFromRootReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getChildrenFromRootResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getChildrenFromRootResponse::getChildrenFromRootReturn);
	/* transient soap skipped */
}

int _ns1__getChildrenFromRootResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getChildrenFromRootResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChildrenFromRootResponse(struct soap *soap, const char *tag, int id, const _ns1__getChildrenFromRootResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChildrenFromRootResponse), type))
		return soap->error;
	if (a->getChildrenFromRootReturn)
		soap_element_result(soap, "ns1:getChildrenFromRootReturn");
	if (a->_ns1__getChildrenFromRootResponse::getChildrenFromRootReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getChildrenFromRootReturn", -1, &a->_ns1__getChildrenFromRootResponse::getChildrenFromRootReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getChildrenFromRootReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getChildrenFromRootResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getChildrenFromRootResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getChildrenFromRootResponse * SOAP_FMAC4 soap_in__ns1__getChildrenFromRootResponse(struct soap *soap, const char *tag, _ns1__getChildrenFromRootResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getChildrenFromRootResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChildrenFromRootResponse, sizeof(_ns1__getChildrenFromRootResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getChildrenFromRootResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getChildrenFromRootResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getChildrenFromRootReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getChildrenFromRootReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getChildrenFromRootReturn", &(a->_ns1__getChildrenFromRootResponse::getChildrenFromRootReturn), "ns2:Map"))
				{	soap_flag_getChildrenFromRootReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getChildrenFromRootReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getChildrenFromRootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChildrenFromRootResponse, 0, sizeof(_ns1__getChildrenFromRootResponse), 0, soap_copy__ns1__getChildrenFromRootResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getChildrenFromRootReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getChildrenFromRootResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getChildrenFromRootResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getChildrenFromRootResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getChildrenFromRootResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getChildrenFromRootResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getChildrenFromRootResponse * SOAP_FMAC4 soap_get__ns1__getChildrenFromRootResponse(struct soap *soap, _ns1__getChildrenFromRootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChildrenFromRootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getChildrenFromRootResponse * SOAP_FMAC2 soap_instantiate__ns1__getChildrenFromRootResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getChildrenFromRootResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getChildrenFromRootResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getChildrenFromRootResponse);
		if (size)
			*size = sizeof(_ns1__getChildrenFromRootResponse);
		((_ns1__getChildrenFromRootResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getChildrenFromRootResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getChildrenFromRootResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getChildrenFromRootResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getChildrenFromRootResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getChildrenFromRootResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getChildrenFromRootResponse %p -> %p\n", q, p));
	*(_ns1__getChildrenFromRootResponse*)p = *(_ns1__getChildrenFromRootResponse*)q;
}

void _ns1__getChildrenFromRoot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getChildrenFromRoot::rootTermId);
	soap_default_std__string(soap, &this->_ns1__getChildrenFromRoot::ontologyName);
	this->_ns1__getChildrenFromRoot::childrenIds = NULL;
	/* transient soap skipped */
}

void _ns1__getChildrenFromRoot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getChildrenFromRoot::rootTermId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getChildrenFromRoot::rootTermId);
	soap_embedded(soap, &this->_ns1__getChildrenFromRoot::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getChildrenFromRoot::ontologyName);
	soap_serialize_PointerTons2__Vector(soap, &this->_ns1__getChildrenFromRoot::childrenIds);
	/* transient soap skipped */
}

int _ns1__getChildrenFromRoot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getChildrenFromRoot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChildrenFromRoot(struct soap *soap, const char *tag, int id, const _ns1__getChildrenFromRoot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChildrenFromRoot), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:rootTermId", -1, &(a->_ns1__getChildrenFromRoot::rootTermId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getChildrenFromRoot::ontologyName), ""))
		return soap->error;
	if (a->_ns1__getChildrenFromRoot::childrenIds)
	{	if (soap_out_PointerTons2__Vector(soap, "ns1:childrenIds", -1, &a->_ns1__getChildrenFromRoot::childrenIds, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:childrenIds"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getChildrenFromRoot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getChildrenFromRoot(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getChildrenFromRoot * SOAP_FMAC4 soap_in__ns1__getChildrenFromRoot(struct soap *soap, const char *tag, _ns1__getChildrenFromRoot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getChildrenFromRoot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChildrenFromRoot, sizeof(_ns1__getChildrenFromRoot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getChildrenFromRoot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getChildrenFromRoot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_rootTermId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	size_t soap_flag_childrenIds1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_rootTermId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:rootTermId", &(a->_ns1__getChildrenFromRoot::rootTermId), "xsd:string"))
				{	soap_flag_rootTermId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getChildrenFromRoot::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			if (soap_flag_childrenIds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector(soap, "ns1:childrenIds", &(a->_ns1__getChildrenFromRoot::childrenIds), "ns2:Vector"))
				{	soap_flag_childrenIds1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getChildrenFromRoot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChildrenFromRoot, 0, sizeof(_ns1__getChildrenFromRoot), 0, soap_copy__ns1__getChildrenFromRoot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_rootTermId1 > 0 || soap_flag_ontologyName1 > 0 || soap_flag_childrenIds1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getChildrenFromRoot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getChildrenFromRoot);
	if (this->soap_out(soap, tag?tag:"ns1:getChildrenFromRoot", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getChildrenFromRoot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getChildrenFromRoot(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getChildrenFromRoot * SOAP_FMAC4 soap_get__ns1__getChildrenFromRoot(struct soap *soap, _ns1__getChildrenFromRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChildrenFromRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getChildrenFromRoot * SOAP_FMAC2 soap_instantiate__ns1__getChildrenFromRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getChildrenFromRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getChildrenFromRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getChildrenFromRoot);
		if (size)
			*size = sizeof(_ns1__getChildrenFromRoot);
		((_ns1__getChildrenFromRoot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getChildrenFromRoot[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getChildrenFromRoot);
		for (int i = 0; i < n; i++)
			((_ns1__getChildrenFromRoot*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getChildrenFromRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getChildrenFromRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getChildrenFromRoot %p -> %p\n", q, p));
	*(_ns1__getChildrenFromRoot*)p = *(_ns1__getChildrenFromRoot*)q;
}

void _ns1__getTermRelationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTermRelationsResponse::getTermRelationsReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTermRelationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getTermRelationsResponse::getTermRelationsReturn);
	/* transient soap skipped */
}

int _ns1__getTermRelationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermRelationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermRelationsResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermRelationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermRelationsResponse), type))
		return soap->error;
	if (a->getTermRelationsReturn)
		soap_element_result(soap, "ns1:getTermRelationsReturn");
	if (a->_ns1__getTermRelationsResponse::getTermRelationsReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getTermRelationsReturn", -1, &a->_ns1__getTermRelationsResponse::getTermRelationsReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTermRelationsReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermRelationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermRelationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermRelationsResponse * SOAP_FMAC4 soap_in__ns1__getTermRelationsResponse(struct soap *soap, const char *tag, _ns1__getTermRelationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermRelationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermRelationsResponse, sizeof(_ns1__getTermRelationsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermRelationsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermRelationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermRelationsReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermRelationsReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getTermRelationsReturn", &(a->_ns1__getTermRelationsResponse::getTermRelationsReturn), "ns2:Map"))
				{	soap_flag_getTermRelationsReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermRelationsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermRelationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermRelationsResponse, 0, sizeof(_ns1__getTermRelationsResponse), 0, soap_copy__ns1__getTermRelationsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermRelationsReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermRelationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermRelationsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermRelationsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermRelationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermRelationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermRelationsResponse * SOAP_FMAC4 soap_get__ns1__getTermRelationsResponse(struct soap *soap, _ns1__getTermRelationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermRelationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermRelationsResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermRelationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermRelationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermRelationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermRelationsResponse);
		if (size)
			*size = sizeof(_ns1__getTermRelationsResponse);
		((_ns1__getTermRelationsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermRelationsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermRelationsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermRelationsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermRelationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermRelationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermRelationsResponse %p -> %p\n", q, p));
	*(_ns1__getTermRelationsResponse*)p = *(_ns1__getTermRelationsResponse*)q;
}

void _ns1__getTermRelations::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermRelations::termId);
	soap_default_std__string(soap, &this->_ns1__getTermRelations::ontologyName);
	/* transient soap skipped */
}

void _ns1__getTermRelations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermRelations::termId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermRelations::termId);
	soap_embedded(soap, &this->_ns1__getTermRelations::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermRelations::ontologyName);
	/* transient soap skipped */
}

int _ns1__getTermRelations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermRelations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermRelations(struct soap *soap, const char *tag, int id, const _ns1__getTermRelations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermRelations), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:termId", -1, &(a->_ns1__getTermRelations::termId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermRelations::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermRelations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermRelations(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermRelations * SOAP_FMAC4 soap_in__ns1__getTermRelations(struct soap *soap, const char *tag, _ns1__getTermRelations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermRelations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermRelations, sizeof(_ns1__getTermRelations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermRelations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermRelations *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:termId", &(a->_ns1__getTermRelations::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermRelations::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermRelations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermRelations, 0, sizeof(_ns1__getTermRelations), 0, soap_copy__ns1__getTermRelations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId1 > 0 || soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermRelations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermRelations);
	if (this->soap_out(soap, tag?tag:"ns1:getTermRelations", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermRelations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermRelations(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermRelations * SOAP_FMAC4 soap_get__ns1__getTermRelations(struct soap *soap, _ns1__getTermRelations *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermRelations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermRelations * SOAP_FMAC2 soap_instantiate__ns1__getTermRelations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermRelations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermRelations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermRelations);
		if (size)
			*size = sizeof(_ns1__getTermRelations);
		((_ns1__getTermRelations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermRelations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermRelations);
		for (int i = 0; i < n; i++)
			((_ns1__getTermRelations*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermRelations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermRelations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermRelations %p -> %p\n", q, p));
	*(_ns1__getTermRelations*)p = *(_ns1__getTermRelations*)q;
}

void _ns1__getTermChildrenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTermChildrenResponse::getTermChildrenReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTermChildrenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getTermChildrenResponse::getTermChildrenReturn);
	/* transient soap skipped */
}

int _ns1__getTermChildrenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermChildrenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermChildrenResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermChildrenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermChildrenResponse), type))
		return soap->error;
	if (a->getTermChildrenReturn)
		soap_element_result(soap, "ns1:getTermChildrenReturn");
	if (a->_ns1__getTermChildrenResponse::getTermChildrenReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getTermChildrenReturn", -1, &a->_ns1__getTermChildrenResponse::getTermChildrenReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTermChildrenReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermChildrenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermChildrenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermChildrenResponse * SOAP_FMAC4 soap_in__ns1__getTermChildrenResponse(struct soap *soap, const char *tag, _ns1__getTermChildrenResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermChildrenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermChildrenResponse, sizeof(_ns1__getTermChildrenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermChildrenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermChildrenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermChildrenReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermChildrenReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getTermChildrenReturn", &(a->_ns1__getTermChildrenResponse::getTermChildrenReturn), "ns2:Map"))
				{	soap_flag_getTermChildrenReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermChildrenReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermChildrenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermChildrenResponse, 0, sizeof(_ns1__getTermChildrenResponse), 0, soap_copy__ns1__getTermChildrenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermChildrenReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermChildrenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermChildrenResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermChildrenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermChildrenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermChildrenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermChildrenResponse * SOAP_FMAC4 soap_get__ns1__getTermChildrenResponse(struct soap *soap, _ns1__getTermChildrenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermChildrenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermChildrenResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermChildrenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermChildrenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermChildrenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermChildrenResponse);
		if (size)
			*size = sizeof(_ns1__getTermChildrenResponse);
		((_ns1__getTermChildrenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermChildrenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermChildrenResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermChildrenResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermChildrenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermChildrenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermChildrenResponse %p -> %p\n", q, p));
	*(_ns1__getTermChildrenResponse*)p = *(_ns1__getTermChildrenResponse*)q;
}

void _ns1__getTermChildren::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermChildren::termId);
	soap_default_std__string(soap, &this->_ns1__getTermChildren::ontologyName);
	soap_default_int(soap, &this->_ns1__getTermChildren::distance);
	soap_default_std__vectorTemplateOfint(soap, &this->_ns1__getTermChildren::relationTypes);
	/* transient soap skipped */
}

void _ns1__getTermChildren::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermChildren::termId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermChildren::termId);
	soap_embedded(soap, &this->_ns1__getTermChildren::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermChildren::ontologyName);
	soap_serialize_std__vectorTemplateOfint(soap, &this->_ns1__getTermChildren::relationTypes);
	/* transient soap skipped */
}

int _ns1__getTermChildren::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermChildren(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermChildren(struct soap *soap, const char *tag, int id, const _ns1__getTermChildren *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermChildren), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:termId", -1, &(a->_ns1__getTermChildren::termId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermChildren::ontologyName), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:distance", -1, &(a->_ns1__getTermChildren::distance), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "ns1:relationTypes", -1, &(a->_ns1__getTermChildren::relationTypes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermChildren::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermChildren(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermChildren * SOAP_FMAC4 soap_in__ns1__getTermChildren(struct soap *soap, const char *tag, _ns1__getTermChildren *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermChildren *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermChildren, sizeof(_ns1__getTermChildren), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermChildren)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermChildren *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	size_t soap_flag_distance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:termId", &(a->_ns1__getTermChildren::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermChildren::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			if (soap_flag_distance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:distance", &(a->_ns1__getTermChildren::distance), "xsd:int"))
				{	soap_flag_distance1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "ns1:relationTypes", &(a->_ns1__getTermChildren::relationTypes), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermChildren *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermChildren, 0, sizeof(_ns1__getTermChildren), 0, soap_copy__ns1__getTermChildren);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId1 > 0 || soap_flag_ontologyName1 > 0 || soap_flag_distance1 > 0 || a->_ns1__getTermChildren::relationTypes.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermChildren::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermChildren);
	if (this->soap_out(soap, tag?tag:"ns1:getTermChildren", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermChildren::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermChildren(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermChildren * SOAP_FMAC4 soap_get__ns1__getTermChildren(struct soap *soap, _ns1__getTermChildren *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermChildren(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermChildren * SOAP_FMAC2 soap_instantiate__ns1__getTermChildren(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermChildren(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermChildren, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermChildren);
		if (size)
			*size = sizeof(_ns1__getTermChildren);
		((_ns1__getTermChildren*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermChildren[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermChildren);
		for (int i = 0; i < n; i++)
			((_ns1__getTermChildren*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermChildren*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermChildren(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermChildren %p -> %p\n", q, p));
	*(_ns1__getTermChildren*)p = *(_ns1__getTermChildren*)q;
}

void _ns1__getTermParentsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTermParentsResponse::getTermParentsReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTermParentsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getTermParentsResponse::getTermParentsReturn);
	/* transient soap skipped */
}

int _ns1__getTermParentsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermParentsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermParentsResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermParentsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermParentsResponse), type))
		return soap->error;
	if (a->getTermParentsReturn)
		soap_element_result(soap, "ns1:getTermParentsReturn");
	if (a->_ns1__getTermParentsResponse::getTermParentsReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getTermParentsReturn", -1, &a->_ns1__getTermParentsResponse::getTermParentsReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTermParentsReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermParentsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermParentsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermParentsResponse * SOAP_FMAC4 soap_in__ns1__getTermParentsResponse(struct soap *soap, const char *tag, _ns1__getTermParentsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermParentsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermParentsResponse, sizeof(_ns1__getTermParentsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermParentsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermParentsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermParentsReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermParentsReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getTermParentsReturn", &(a->_ns1__getTermParentsResponse::getTermParentsReturn), "ns2:Map"))
				{	soap_flag_getTermParentsReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermParentsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermParentsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermParentsResponse, 0, sizeof(_ns1__getTermParentsResponse), 0, soap_copy__ns1__getTermParentsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermParentsReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermParentsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermParentsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermParentsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermParentsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermParentsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermParentsResponse * SOAP_FMAC4 soap_get__ns1__getTermParentsResponse(struct soap *soap, _ns1__getTermParentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermParentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermParentsResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermParentsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermParentsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermParentsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermParentsResponse);
		if (size)
			*size = sizeof(_ns1__getTermParentsResponse);
		((_ns1__getTermParentsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermParentsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermParentsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermParentsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermParentsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermParentsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermParentsResponse %p -> %p\n", q, p));
	*(_ns1__getTermParentsResponse*)p = *(_ns1__getTermParentsResponse*)q;
}

void _ns1__getTermParents::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermParents::termId);
	soap_default_std__string(soap, &this->_ns1__getTermParents::ontologyName);
	/* transient soap skipped */
}

void _ns1__getTermParents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermParents::termId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermParents::termId);
	soap_embedded(soap, &this->_ns1__getTermParents::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermParents::ontologyName);
	/* transient soap skipped */
}

int _ns1__getTermParents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermParents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermParents(struct soap *soap, const char *tag, int id, const _ns1__getTermParents *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermParents), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:termId", -1, &(a->_ns1__getTermParents::termId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermParents::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermParents::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermParents(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermParents * SOAP_FMAC4 soap_in__ns1__getTermParents(struct soap *soap, const char *tag, _ns1__getTermParents *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermParents *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermParents, sizeof(_ns1__getTermParents), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermParents)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermParents *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:termId", &(a->_ns1__getTermParents::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermParents::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermParents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermParents, 0, sizeof(_ns1__getTermParents), 0, soap_copy__ns1__getTermParents);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId1 > 0 || soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermParents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermParents);
	if (this->soap_out(soap, tag?tag:"ns1:getTermParents", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermParents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermParents(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermParents * SOAP_FMAC4 soap_get__ns1__getTermParents(struct soap *soap, _ns1__getTermParents *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermParents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermParents * SOAP_FMAC2 soap_instantiate__ns1__getTermParents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermParents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermParents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermParents);
		if (size)
			*size = sizeof(_ns1__getTermParents);
		((_ns1__getTermParents*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermParents[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermParents);
		for (int i = 0; i < n; i++)
			((_ns1__getTermParents*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermParents*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermParents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermParents %p -> %p\n", q, p));
	*(_ns1__getTermParents*)p = *(_ns1__getTermParents*)q;
}

void _ns1__getPrefixedTermsByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getPrefixedTermsByNameResponse::getPrefixedTermsByNameReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getPrefixedTermsByNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getPrefixedTermsByNameResponse::getPrefixedTermsByNameReturn);
	/* transient soap skipped */
}

int _ns1__getPrefixedTermsByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPrefixedTermsByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrefixedTermsByNameResponse(struct soap *soap, const char *tag, int id, const _ns1__getPrefixedTermsByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse), type))
		return soap->error;
	if (a->getPrefixedTermsByNameReturn)
		soap_element_result(soap, "ns1:getPrefixedTermsByNameReturn");
	if (a->_ns1__getPrefixedTermsByNameResponse::getPrefixedTermsByNameReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getPrefixedTermsByNameReturn", -1, &a->_ns1__getPrefixedTermsByNameResponse::getPrefixedTermsByNameReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getPrefixedTermsByNameReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPrefixedTermsByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPrefixedTermsByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByNameResponse * SOAP_FMAC4 soap_in__ns1__getPrefixedTermsByNameResponse(struct soap *soap, const char *tag, _ns1__getPrefixedTermsByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPrefixedTermsByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse, sizeof(_ns1__getPrefixedTermsByNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getPrefixedTermsByNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getPrefixedTermsByNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getPrefixedTermsByNameReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getPrefixedTermsByNameReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getPrefixedTermsByNameReturn", &(a->_ns1__getPrefixedTermsByNameResponse::getPrefixedTermsByNameReturn), "ns2:Map"))
				{	soap_flag_getPrefixedTermsByNameReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getPrefixedTermsByNameReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPrefixedTermsByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse, 0, sizeof(_ns1__getPrefixedTermsByNameResponse), 0, soap_copy__ns1__getPrefixedTermsByNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getPrefixedTermsByNameReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getPrefixedTermsByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getPrefixedTermsByNameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPrefixedTermsByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPrefixedTermsByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByNameResponse * SOAP_FMAC4 soap_get__ns1__getPrefixedTermsByNameResponse(struct soap *soap, _ns1__getPrefixedTermsByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrefixedTermsByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getPrefixedTermsByNameResponse * SOAP_FMAC2 soap_instantiate__ns1__getPrefixedTermsByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPrefixedTermsByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPrefixedTermsByNameResponse);
		if (size)
			*size = sizeof(_ns1__getPrefixedTermsByNameResponse);
		((_ns1__getPrefixedTermsByNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPrefixedTermsByNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getPrefixedTermsByNameResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getPrefixedTermsByNameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getPrefixedTermsByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getPrefixedTermsByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getPrefixedTermsByNameResponse %p -> %p\n", q, p));
	*(_ns1__getPrefixedTermsByNameResponse*)p = *(_ns1__getPrefixedTermsByNameResponse*)q;
}

void _ns1__getPrefixedTermsByName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getPrefixedTermsByName::partialName);
	soap_default_bool(soap, &this->_ns1__getPrefixedTermsByName::reverseKeyOrder);
	/* transient soap skipped */
}

void _ns1__getPrefixedTermsByName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getPrefixedTermsByName::partialName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getPrefixedTermsByName::partialName);
	/* transient soap skipped */
}

int _ns1__getPrefixedTermsByName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPrefixedTermsByName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrefixedTermsByName(struct soap *soap, const char *tag, int id, const _ns1__getPrefixedTermsByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrefixedTermsByName), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:partialName", -1, &(a->_ns1__getPrefixedTermsByName::partialName), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:reverseKeyOrder", -1, &(a->_ns1__getPrefixedTermsByName::reverseKeyOrder), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPrefixedTermsByName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPrefixedTermsByName(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByName * SOAP_FMAC4 soap_in__ns1__getPrefixedTermsByName(struct soap *soap, const char *tag, _ns1__getPrefixedTermsByName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPrefixedTermsByName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrefixedTermsByName, sizeof(_ns1__getPrefixedTermsByName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getPrefixedTermsByName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getPrefixedTermsByName *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_partialName1 = 1;
	size_t soap_flag_reverseKeyOrder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_partialName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:partialName", &(a->_ns1__getPrefixedTermsByName::partialName), "xsd:string"))
				{	soap_flag_partialName1--;
					continue;
				}
			if (soap_flag_reverseKeyOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:reverseKeyOrder", &(a->_ns1__getPrefixedTermsByName::reverseKeyOrder), "xsd:boolean"))
				{	soap_flag_reverseKeyOrder1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPrefixedTermsByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrefixedTermsByName, 0, sizeof(_ns1__getPrefixedTermsByName), 0, soap_copy__ns1__getPrefixedTermsByName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_partialName1 > 0 || soap_flag_reverseKeyOrder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getPrefixedTermsByName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getPrefixedTermsByName);
	if (this->soap_out(soap, tag?tag:"ns1:getPrefixedTermsByName", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPrefixedTermsByName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPrefixedTermsByName(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByName * SOAP_FMAC4 soap_get__ns1__getPrefixedTermsByName(struct soap *soap, _ns1__getPrefixedTermsByName *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrefixedTermsByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getPrefixedTermsByName * SOAP_FMAC2 soap_instantiate__ns1__getPrefixedTermsByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPrefixedTermsByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getPrefixedTermsByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPrefixedTermsByName);
		if (size)
			*size = sizeof(_ns1__getPrefixedTermsByName);
		((_ns1__getPrefixedTermsByName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPrefixedTermsByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getPrefixedTermsByName);
		for (int i = 0; i < n; i++)
			((_ns1__getPrefixedTermsByName*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getPrefixedTermsByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getPrefixedTermsByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getPrefixedTermsByName %p -> %p\n", q, p));
	*(_ns1__getPrefixedTermsByName*)p = *(_ns1__getPrefixedTermsByName*)q;
}

void _ns1__getTermsByExactNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTermsByExactNameResponse::getTermsByExactNameReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTermsByExactNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getTermsByExactNameResponse::getTermsByExactNameReturn);
	/* transient soap skipped */
}

int _ns1__getTermsByExactNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermsByExactNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermsByExactNameResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermsByExactNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermsByExactNameResponse), type))
		return soap->error;
	if (a->getTermsByExactNameReturn)
		soap_element_result(soap, "ns1:getTermsByExactNameReturn");
	if (a->_ns1__getTermsByExactNameResponse::getTermsByExactNameReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getTermsByExactNameReturn", -1, &a->_ns1__getTermsByExactNameResponse::getTermsByExactNameReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTermsByExactNameReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermsByExactNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermsByExactNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermsByExactNameResponse * SOAP_FMAC4 soap_in__ns1__getTermsByExactNameResponse(struct soap *soap, const char *tag, _ns1__getTermsByExactNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermsByExactNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermsByExactNameResponse, sizeof(_ns1__getTermsByExactNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermsByExactNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermsByExactNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermsByExactNameReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermsByExactNameReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getTermsByExactNameReturn", &(a->_ns1__getTermsByExactNameResponse::getTermsByExactNameReturn), "ns2:Map"))
				{	soap_flag_getTermsByExactNameReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermsByExactNameReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermsByExactNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermsByExactNameResponse, 0, sizeof(_ns1__getTermsByExactNameResponse), 0, soap_copy__ns1__getTermsByExactNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermsByExactNameReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermsByExactNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermsByExactNameResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermsByExactNameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermsByExactNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermsByExactNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermsByExactNameResponse * SOAP_FMAC4 soap_get__ns1__getTermsByExactNameResponse(struct soap *soap, _ns1__getTermsByExactNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermsByExactNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermsByExactNameResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermsByExactNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermsByExactNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermsByExactNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByExactNameResponse);
		if (size)
			*size = sizeof(_ns1__getTermsByExactNameResponse);
		((_ns1__getTermsByExactNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByExactNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermsByExactNameResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermsByExactNameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermsByExactNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermsByExactNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermsByExactNameResponse %p -> %p\n", q, p));
	*(_ns1__getTermsByExactNameResponse*)p = *(_ns1__getTermsByExactNameResponse*)q;
}

void _ns1__getTermsByExactName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermsByExactName::exactName);
	soap_default_std__string(soap, &this->_ns1__getTermsByExactName::ontologyName);
	/* transient soap skipped */
}

void _ns1__getTermsByExactName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermsByExactName::exactName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermsByExactName::exactName);
	soap_embedded(soap, &this->_ns1__getTermsByExactName::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermsByExactName::ontologyName);
	/* transient soap skipped */
}

int _ns1__getTermsByExactName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermsByExactName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermsByExactName(struct soap *soap, const char *tag, int id, const _ns1__getTermsByExactName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermsByExactName), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:exactName", -1, &(a->_ns1__getTermsByExactName::exactName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermsByExactName::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermsByExactName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermsByExactName(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermsByExactName * SOAP_FMAC4 soap_in__ns1__getTermsByExactName(struct soap *soap, const char *tag, _ns1__getTermsByExactName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermsByExactName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermsByExactName, sizeof(_ns1__getTermsByExactName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermsByExactName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermsByExactName *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_exactName1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_exactName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:exactName", &(a->_ns1__getTermsByExactName::exactName), "xsd:string"))
				{	soap_flag_exactName1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermsByExactName::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermsByExactName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermsByExactName, 0, sizeof(_ns1__getTermsByExactName), 0, soap_copy__ns1__getTermsByExactName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_exactName1 > 0 || soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermsByExactName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermsByExactName);
	if (this->soap_out(soap, tag?tag:"ns1:getTermsByExactName", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermsByExactName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermsByExactName(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermsByExactName * SOAP_FMAC4 soap_get__ns1__getTermsByExactName(struct soap *soap, _ns1__getTermsByExactName *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermsByExactName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermsByExactName * SOAP_FMAC2 soap_instantiate__ns1__getTermsByExactName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermsByExactName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermsByExactName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByExactName);
		if (size)
			*size = sizeof(_ns1__getTermsByExactName);
		((_ns1__getTermsByExactName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByExactName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermsByExactName);
		for (int i = 0; i < n; i++)
			((_ns1__getTermsByExactName*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermsByExactName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermsByExactName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermsByExactName %p -> %p\n", q, p));
	*(_ns1__getTermsByExactName*)p = *(_ns1__getTermsByExactName*)q;
}

void _ns1__getTermsByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTermsByNameResponse::getTermsByNameReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTermsByNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getTermsByNameResponse::getTermsByNameReturn);
	/* transient soap skipped */
}

int _ns1__getTermsByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermsByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermsByNameResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermsByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermsByNameResponse), type))
		return soap->error;
	if (a->getTermsByNameReturn)
		soap_element_result(soap, "ns1:getTermsByNameReturn");
	if (a->_ns1__getTermsByNameResponse::getTermsByNameReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getTermsByNameReturn", -1, &a->_ns1__getTermsByNameResponse::getTermsByNameReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTermsByNameReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermsByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermsByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermsByNameResponse * SOAP_FMAC4 soap_in__ns1__getTermsByNameResponse(struct soap *soap, const char *tag, _ns1__getTermsByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermsByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermsByNameResponse, sizeof(_ns1__getTermsByNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermsByNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermsByNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermsByNameReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermsByNameReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getTermsByNameReturn", &(a->_ns1__getTermsByNameResponse::getTermsByNameReturn), "ns2:Map"))
				{	soap_flag_getTermsByNameReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermsByNameReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermsByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermsByNameResponse, 0, sizeof(_ns1__getTermsByNameResponse), 0, soap_copy__ns1__getTermsByNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermsByNameReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermsByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermsByNameResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermsByNameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermsByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermsByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermsByNameResponse * SOAP_FMAC4 soap_get__ns1__getTermsByNameResponse(struct soap *soap, _ns1__getTermsByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermsByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermsByNameResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermsByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermsByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermsByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByNameResponse);
		if (size)
			*size = sizeof(_ns1__getTermsByNameResponse);
		((_ns1__getTermsByNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermsByNameResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermsByNameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermsByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermsByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermsByNameResponse %p -> %p\n", q, p));
	*(_ns1__getTermsByNameResponse*)p = *(_ns1__getTermsByNameResponse*)q;
}

void _ns1__getTermsByName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermsByName::partialName);
	soap_default_std__string(soap, &this->_ns1__getTermsByName::ontologyName);
	soap_default_bool(soap, &this->_ns1__getTermsByName::reverseKeyOrder);
	/* transient soap skipped */
}

void _ns1__getTermsByName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermsByName::partialName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermsByName::partialName);
	soap_embedded(soap, &this->_ns1__getTermsByName::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermsByName::ontologyName);
	/* transient soap skipped */
}

int _ns1__getTermsByName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermsByName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermsByName(struct soap *soap, const char *tag, int id, const _ns1__getTermsByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermsByName), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:partialName", -1, &(a->_ns1__getTermsByName::partialName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermsByName::ontologyName), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:reverseKeyOrder", -1, &(a->_ns1__getTermsByName::reverseKeyOrder), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermsByName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermsByName(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermsByName * SOAP_FMAC4 soap_in__ns1__getTermsByName(struct soap *soap, const char *tag, _ns1__getTermsByName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermsByName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermsByName, sizeof(_ns1__getTermsByName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermsByName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermsByName *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_partialName1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	size_t soap_flag_reverseKeyOrder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_partialName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:partialName", &(a->_ns1__getTermsByName::partialName), "xsd:string"))
				{	soap_flag_partialName1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermsByName::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			if (soap_flag_reverseKeyOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:reverseKeyOrder", &(a->_ns1__getTermsByName::reverseKeyOrder), "xsd:boolean"))
				{	soap_flag_reverseKeyOrder1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermsByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermsByName, 0, sizeof(_ns1__getTermsByName), 0, soap_copy__ns1__getTermsByName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_partialName1 > 0 || soap_flag_ontologyName1 > 0 || soap_flag_reverseKeyOrder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermsByName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermsByName);
	if (this->soap_out(soap, tag?tag:"ns1:getTermsByName", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermsByName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermsByName(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermsByName * SOAP_FMAC4 soap_get__ns1__getTermsByName(struct soap *soap, _ns1__getTermsByName *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermsByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermsByName * SOAP_FMAC2 soap_instantiate__ns1__getTermsByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermsByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermsByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByName);
		if (size)
			*size = sizeof(_ns1__getTermsByName);
		((_ns1__getTermsByName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermsByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermsByName);
		for (int i = 0; i < n; i++)
			((_ns1__getTermsByName*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermsByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermsByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermsByName %p -> %p\n", q, p));
	*(_ns1__getTermsByName*)p = *(_ns1__getTermsByName*)q;
}

void _ns1__getRootTermsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getRootTermsResponse::getRootTermsReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getRootTermsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getRootTermsResponse::getRootTermsReturn);
	/* transient soap skipped */
}

int _ns1__getRootTermsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRootTermsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRootTermsResponse(struct soap *soap, const char *tag, int id, const _ns1__getRootTermsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRootTermsResponse), type))
		return soap->error;
	if (a->getRootTermsReturn)
		soap_element_result(soap, "ns1:getRootTermsReturn");
	if (a->_ns1__getRootTermsResponse::getRootTermsReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getRootTermsReturn", -1, &a->_ns1__getRootTermsResponse::getRootTermsReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getRootTermsReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRootTermsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRootTermsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRootTermsResponse * SOAP_FMAC4 soap_in__ns1__getRootTermsResponse(struct soap *soap, const char *tag, _ns1__getRootTermsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRootTermsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRootTermsResponse, sizeof(_ns1__getRootTermsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRootTermsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRootTermsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getRootTermsReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getRootTermsReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getRootTermsReturn", &(a->_ns1__getRootTermsResponse::getRootTermsReturn), "ns2:Map"))
				{	soap_flag_getRootTermsReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getRootTermsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRootTermsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRootTermsResponse, 0, sizeof(_ns1__getRootTermsResponse), 0, soap_copy__ns1__getRootTermsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getRootTermsReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getRootTermsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRootTermsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getRootTermsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRootTermsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRootTermsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRootTermsResponse * SOAP_FMAC4 soap_get__ns1__getRootTermsResponse(struct soap *soap, _ns1__getRootTermsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRootTermsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getRootTermsResponse * SOAP_FMAC2 soap_instantiate__ns1__getRootTermsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRootTermsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRootTermsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getRootTermsResponse);
		if (size)
			*size = sizeof(_ns1__getRootTermsResponse);
		((_ns1__getRootTermsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getRootTermsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRootTermsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getRootTermsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRootTermsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRootTermsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRootTermsResponse %p -> %p\n", q, p));
	*(_ns1__getRootTermsResponse*)p = *(_ns1__getRootTermsResponse*)q;
}

void _ns1__getRootTerms::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getRootTerms::ontologyName);
	/* transient soap skipped */
}

void _ns1__getRootTerms::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getRootTerms::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getRootTerms::ontologyName);
	/* transient soap skipped */
}

int _ns1__getRootTerms::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRootTerms(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRootTerms(struct soap *soap, const char *tag, int id, const _ns1__getRootTerms *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRootTerms), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getRootTerms::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRootTerms::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRootTerms(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRootTerms * SOAP_FMAC4 soap_in__ns1__getRootTerms(struct soap *soap, const char *tag, _ns1__getRootTerms *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRootTerms *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRootTerms, sizeof(_ns1__getRootTerms), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRootTerms)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRootTerms *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getRootTerms::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRootTerms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRootTerms, 0, sizeof(_ns1__getRootTerms), 0, soap_copy__ns1__getRootTerms);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getRootTerms::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRootTerms);
	if (this->soap_out(soap, tag?tag:"ns1:getRootTerms", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRootTerms::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRootTerms(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRootTerms * SOAP_FMAC4 soap_get__ns1__getRootTerms(struct soap *soap, _ns1__getRootTerms *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRootTerms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getRootTerms * SOAP_FMAC2 soap_instantiate__ns1__getRootTerms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRootTerms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRootTerms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getRootTerms);
		if (size)
			*size = sizeof(_ns1__getRootTerms);
		((_ns1__getRootTerms*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getRootTerms[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRootTerms);
		for (int i = 0; i < n; i++)
			((_ns1__getRootTerms*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRootTerms*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRootTerms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRootTerms %p -> %p\n", q, p));
	*(_ns1__getRootTerms*)p = *(_ns1__getRootTerms*)q;
}

void _ns1__getAllTermsFromOntologyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getAllTermsFromOntologyResponse::getAllTermsFromOntologyReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getAllTermsFromOntologyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getAllTermsFromOntologyResponse::getAllTermsFromOntologyReturn);
	/* transient soap skipped */
}

int _ns1__getAllTermsFromOntologyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllTermsFromOntologyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllTermsFromOntologyResponse(struct soap *soap, const char *tag, int id, const _ns1__getAllTermsFromOntologyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse), type))
		return soap->error;
	if (a->getAllTermsFromOntologyReturn)
		soap_element_result(soap, "ns1:getAllTermsFromOntologyReturn");
	if (a->_ns1__getAllTermsFromOntologyResponse::getAllTermsFromOntologyReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getAllTermsFromOntologyReturn", -1, &a->_ns1__getAllTermsFromOntologyResponse::getAllTermsFromOntologyReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getAllTermsFromOntologyReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllTermsFromOntologyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllTermsFromOntologyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntologyResponse * SOAP_FMAC4 soap_in__ns1__getAllTermsFromOntologyResponse(struct soap *soap, const char *tag, _ns1__getAllTermsFromOntologyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllTermsFromOntologyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse, sizeof(_ns1__getAllTermsFromOntologyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllTermsFromOntologyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllTermsFromOntologyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getAllTermsFromOntologyReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getAllTermsFromOntologyReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getAllTermsFromOntologyReturn", &(a->_ns1__getAllTermsFromOntologyResponse::getAllTermsFromOntologyReturn), "ns2:Map"))
				{	soap_flag_getAllTermsFromOntologyReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getAllTermsFromOntologyReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllTermsFromOntologyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse, 0, sizeof(_ns1__getAllTermsFromOntologyResponse), 0, soap_copy__ns1__getAllTermsFromOntologyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getAllTermsFromOntologyReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllTermsFromOntologyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAllTermsFromOntologyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllTermsFromOntologyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllTermsFromOntologyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntologyResponse * SOAP_FMAC4 soap_get__ns1__getAllTermsFromOntologyResponse(struct soap *soap, _ns1__getAllTermsFromOntologyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllTermsFromOntologyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllTermsFromOntologyResponse * SOAP_FMAC2 soap_instantiate__ns1__getAllTermsFromOntologyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllTermsFromOntologyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllTermsFromOntologyResponse);
		if (size)
			*size = sizeof(_ns1__getAllTermsFromOntologyResponse);
		((_ns1__getAllTermsFromOntologyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllTermsFromOntologyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllTermsFromOntologyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getAllTermsFromOntologyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllTermsFromOntologyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllTermsFromOntologyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllTermsFromOntologyResponse %p -> %p\n", q, p));
	*(_ns1__getAllTermsFromOntologyResponse*)p = *(_ns1__getAllTermsFromOntologyResponse*)q;
}

void _ns1__getAllTermsFromOntology::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getAllTermsFromOntology::ontologyName);
	/* transient soap skipped */
}

void _ns1__getAllTermsFromOntology::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getAllTermsFromOntology::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getAllTermsFromOntology::ontologyName);
	/* transient soap skipped */
}

int _ns1__getAllTermsFromOntology::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAllTermsFromOntology(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllTermsFromOntology(struct soap *soap, const char *tag, int id, const _ns1__getAllTermsFromOntology *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllTermsFromOntology), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getAllTermsFromOntology::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAllTermsFromOntology::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAllTermsFromOntology(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntology * SOAP_FMAC4 soap_in__ns1__getAllTermsFromOntology(struct soap *soap, const char *tag, _ns1__getAllTermsFromOntology *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAllTermsFromOntology *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllTermsFromOntology, sizeof(_ns1__getAllTermsFromOntology), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAllTermsFromOntology)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAllTermsFromOntology *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getAllTermsFromOntology::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAllTermsFromOntology *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllTermsFromOntology, 0, sizeof(_ns1__getAllTermsFromOntology), 0, soap_copy__ns1__getAllTermsFromOntology);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAllTermsFromOntology::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAllTermsFromOntology);
	if (this->soap_out(soap, tag?tag:"ns1:getAllTermsFromOntology", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAllTermsFromOntology::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAllTermsFromOntology(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntology * SOAP_FMAC4 soap_get__ns1__getAllTermsFromOntology(struct soap *soap, _ns1__getAllTermsFromOntology *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllTermsFromOntology(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAllTermsFromOntology * SOAP_FMAC2 soap_instantiate__ns1__getAllTermsFromOntology(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAllTermsFromOntology(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAllTermsFromOntology, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllTermsFromOntology);
		if (size)
			*size = sizeof(_ns1__getAllTermsFromOntology);
		((_ns1__getAllTermsFromOntology*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAllTermsFromOntology[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAllTermsFromOntology);
		for (int i = 0; i < n; i++)
			((_ns1__getAllTermsFromOntology*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAllTermsFromOntology*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAllTermsFromOntology(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAllTermsFromOntology %p -> %p\n", q, p));
	*(_ns1__getAllTermsFromOntology*)p = *(_ns1__getAllTermsFromOntology*)q;
}

void _ns1__getOntologyLoadDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getOntologyLoadDateResponse::getOntologyLoadDateReturn);
	/* transient soap skipped */
}

void _ns1__getOntologyLoadDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getOntologyLoadDateResponse::getOntologyLoadDateReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getOntologyLoadDateResponse::getOntologyLoadDateReturn);
	/* transient soap skipped */
}

int _ns1__getOntologyLoadDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getOntologyLoadDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOntologyLoadDateResponse(struct soap *soap, const char *tag, int id, const _ns1__getOntologyLoadDateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOntologyLoadDateResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:getOntologyLoadDateReturn");
	if (soap_out_std__string(soap, "ns1:getOntologyLoadDateReturn", -1, &(a->_ns1__getOntologyLoadDateResponse::getOntologyLoadDateReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getOntologyLoadDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getOntologyLoadDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getOntologyLoadDateResponse * SOAP_FMAC4 soap_in__ns1__getOntologyLoadDateResponse(struct soap *soap, const char *tag, _ns1__getOntologyLoadDateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getOntologyLoadDateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOntologyLoadDateResponse, sizeof(_ns1__getOntologyLoadDateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getOntologyLoadDateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getOntologyLoadDateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getOntologyLoadDateReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getOntologyLoadDateReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:getOntologyLoadDateReturn", &(a->_ns1__getOntologyLoadDateResponse::getOntologyLoadDateReturn), "xsd:string"))
				{	soap_flag_getOntologyLoadDateReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getOntologyLoadDateReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getOntologyLoadDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOntologyLoadDateResponse, 0, sizeof(_ns1__getOntologyLoadDateResponse), 0, soap_copy__ns1__getOntologyLoadDateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getOntologyLoadDateReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getOntologyLoadDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getOntologyLoadDateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getOntologyLoadDateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getOntologyLoadDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getOntologyLoadDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getOntologyLoadDateResponse * SOAP_FMAC4 soap_get__ns1__getOntologyLoadDateResponse(struct soap *soap, _ns1__getOntologyLoadDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOntologyLoadDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getOntologyLoadDateResponse * SOAP_FMAC2 soap_instantiate__ns1__getOntologyLoadDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getOntologyLoadDateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getOntologyLoadDateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyLoadDateResponse);
		if (size)
			*size = sizeof(_ns1__getOntologyLoadDateResponse);
		((_ns1__getOntologyLoadDateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyLoadDateResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getOntologyLoadDateResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getOntologyLoadDateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getOntologyLoadDateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getOntologyLoadDateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getOntologyLoadDateResponse %p -> %p\n", q, p));
	*(_ns1__getOntologyLoadDateResponse*)p = *(_ns1__getOntologyLoadDateResponse*)q;
}

void _ns1__getOntologyLoadDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getOntologyLoadDate::ontologyName);
	/* transient soap skipped */
}

void _ns1__getOntologyLoadDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getOntologyLoadDate::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getOntologyLoadDate::ontologyName);
	/* transient soap skipped */
}

int _ns1__getOntologyLoadDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getOntologyLoadDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOntologyLoadDate(struct soap *soap, const char *tag, int id, const _ns1__getOntologyLoadDate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOntologyLoadDate), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getOntologyLoadDate::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getOntologyLoadDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getOntologyLoadDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getOntologyLoadDate * SOAP_FMAC4 soap_in__ns1__getOntologyLoadDate(struct soap *soap, const char *tag, _ns1__getOntologyLoadDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getOntologyLoadDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOntologyLoadDate, sizeof(_ns1__getOntologyLoadDate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getOntologyLoadDate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getOntologyLoadDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getOntologyLoadDate::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getOntologyLoadDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOntologyLoadDate, 0, sizeof(_ns1__getOntologyLoadDate), 0, soap_copy__ns1__getOntologyLoadDate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getOntologyLoadDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getOntologyLoadDate);
	if (this->soap_out(soap, tag?tag:"ns1:getOntologyLoadDate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getOntologyLoadDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getOntologyLoadDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getOntologyLoadDate * SOAP_FMAC4 soap_get__ns1__getOntologyLoadDate(struct soap *soap, _ns1__getOntologyLoadDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOntologyLoadDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getOntologyLoadDate * SOAP_FMAC2 soap_instantiate__ns1__getOntologyLoadDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getOntologyLoadDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getOntologyLoadDate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyLoadDate);
		if (size)
			*size = sizeof(_ns1__getOntologyLoadDate);
		((_ns1__getOntologyLoadDate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyLoadDate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getOntologyLoadDate);
		for (int i = 0; i < n; i++)
			((_ns1__getOntologyLoadDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getOntologyLoadDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getOntologyLoadDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getOntologyLoadDate %p -> %p\n", q, p));
	*(_ns1__getOntologyLoadDate*)p = *(_ns1__getOntologyLoadDate*)q;
}

void _ns1__getOntologyNamesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getOntologyNamesResponse::getOntologyNamesReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getOntologyNamesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getOntologyNamesResponse::getOntologyNamesReturn);
	/* transient soap skipped */
}

int _ns1__getOntologyNamesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getOntologyNamesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOntologyNamesResponse(struct soap *soap, const char *tag, int id, const _ns1__getOntologyNamesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOntologyNamesResponse), type))
		return soap->error;
	if (a->getOntologyNamesReturn)
		soap_element_result(soap, "ns1:getOntologyNamesReturn");
	if (a->_ns1__getOntologyNamesResponse::getOntologyNamesReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getOntologyNamesReturn", -1, &a->_ns1__getOntologyNamesResponse::getOntologyNamesReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getOntologyNamesReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getOntologyNamesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getOntologyNamesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getOntologyNamesResponse * SOAP_FMAC4 soap_in__ns1__getOntologyNamesResponse(struct soap *soap, const char *tag, _ns1__getOntologyNamesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getOntologyNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOntologyNamesResponse, sizeof(_ns1__getOntologyNamesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getOntologyNamesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getOntologyNamesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getOntologyNamesReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getOntologyNamesReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getOntologyNamesReturn", &(a->_ns1__getOntologyNamesResponse::getOntologyNamesReturn), "ns2:Map"))
				{	soap_flag_getOntologyNamesReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getOntologyNamesReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getOntologyNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOntologyNamesResponse, 0, sizeof(_ns1__getOntologyNamesResponse), 0, soap_copy__ns1__getOntologyNamesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getOntologyNamesReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getOntologyNamesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getOntologyNamesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getOntologyNamesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getOntologyNamesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getOntologyNamesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getOntologyNamesResponse * SOAP_FMAC4 soap_get__ns1__getOntologyNamesResponse(struct soap *soap, _ns1__getOntologyNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOntologyNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getOntologyNamesResponse * SOAP_FMAC2 soap_instantiate__ns1__getOntologyNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getOntologyNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getOntologyNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyNamesResponse);
		if (size)
			*size = sizeof(_ns1__getOntologyNamesResponse);
		((_ns1__getOntologyNamesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyNamesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getOntologyNamesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getOntologyNamesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getOntologyNamesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getOntologyNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getOntologyNamesResponse %p -> %p\n", q, p));
	*(_ns1__getOntologyNamesResponse*)p = *(_ns1__getOntologyNamesResponse*)q;
}

void _ns1__getOntologyNames::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getOntologyNames::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getOntologyNames::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getOntologyNames(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOntologyNames(struct soap *soap, const char *tag, int id, const _ns1__getOntologyNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOntologyNames), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getOntologyNames::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getOntologyNames(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getOntologyNames * SOAP_FMAC4 soap_in__ns1__getOntologyNames(struct soap *soap, const char *tag, _ns1__getOntologyNames *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getOntologyNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOntologyNames, sizeof(_ns1__getOntologyNames), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getOntologyNames)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getOntologyNames *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getOntologyNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOntologyNames, 0, sizeof(_ns1__getOntologyNames), 0, soap_copy__ns1__getOntologyNames);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__getOntologyNames::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getOntologyNames);
	if (this->soap_out(soap, tag?tag:"ns1:getOntologyNames", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getOntologyNames::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getOntologyNames(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getOntologyNames * SOAP_FMAC4 soap_get__ns1__getOntologyNames(struct soap *soap, _ns1__getOntologyNames *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOntologyNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getOntologyNames * SOAP_FMAC2 soap_instantiate__ns1__getOntologyNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getOntologyNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getOntologyNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyNames);
		if (size)
			*size = sizeof(_ns1__getOntologyNames);
		((_ns1__getOntologyNames*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getOntologyNames[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getOntologyNames);
		for (int i = 0; i < n; i++)
			((_ns1__getOntologyNames*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getOntologyNames*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getOntologyNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getOntologyNames %p -> %p\n", q, p));
	*(_ns1__getOntologyNames*)p = *(_ns1__getOntologyNames*)q;
}

void _ns1__getTermXrefsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTermXrefsResponse::getTermXrefsReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTermXrefsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getTermXrefsResponse::getTermXrefsReturn);
	/* transient soap skipped */
}

int _ns1__getTermXrefsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermXrefsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermXrefsResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermXrefsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermXrefsResponse), type))
		return soap->error;
	if (a->getTermXrefsReturn)
		soap_element_result(soap, "ns1:getTermXrefsReturn");
	if (a->_ns1__getTermXrefsResponse::getTermXrefsReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getTermXrefsReturn", -1, &a->_ns1__getTermXrefsResponse::getTermXrefsReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTermXrefsReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermXrefsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermXrefsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermXrefsResponse * SOAP_FMAC4 soap_in__ns1__getTermXrefsResponse(struct soap *soap, const char *tag, _ns1__getTermXrefsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermXrefsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermXrefsResponse, sizeof(_ns1__getTermXrefsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermXrefsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermXrefsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermXrefsReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermXrefsReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getTermXrefsReturn", &(a->_ns1__getTermXrefsResponse::getTermXrefsReturn), "ns2:Map"))
				{	soap_flag_getTermXrefsReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermXrefsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermXrefsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermXrefsResponse, 0, sizeof(_ns1__getTermXrefsResponse), 0, soap_copy__ns1__getTermXrefsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermXrefsReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermXrefsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermXrefsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermXrefsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermXrefsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermXrefsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermXrefsResponse * SOAP_FMAC4 soap_get__ns1__getTermXrefsResponse(struct soap *soap, _ns1__getTermXrefsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermXrefsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermXrefsResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermXrefsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermXrefsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermXrefsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermXrefsResponse);
		if (size)
			*size = sizeof(_ns1__getTermXrefsResponse);
		((_ns1__getTermXrefsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermXrefsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermXrefsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermXrefsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermXrefsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermXrefsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermXrefsResponse %p -> %p\n", q, p));
	*(_ns1__getTermXrefsResponse*)p = *(_ns1__getTermXrefsResponse*)q;
}

void _ns1__getTermXrefs::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermXrefs::termId);
	soap_default_std__string(soap, &this->_ns1__getTermXrefs::ontologyName);
	/* transient soap skipped */
}

void _ns1__getTermXrefs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermXrefs::termId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermXrefs::termId);
	soap_embedded(soap, &this->_ns1__getTermXrefs::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermXrefs::ontologyName);
	/* transient soap skipped */
}

int _ns1__getTermXrefs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermXrefs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermXrefs(struct soap *soap, const char *tag, int id, const _ns1__getTermXrefs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermXrefs), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:termId", -1, &(a->_ns1__getTermXrefs::termId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermXrefs::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermXrefs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermXrefs(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermXrefs * SOAP_FMAC4 soap_in__ns1__getTermXrefs(struct soap *soap, const char *tag, _ns1__getTermXrefs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermXrefs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermXrefs, sizeof(_ns1__getTermXrefs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermXrefs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermXrefs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:termId", &(a->_ns1__getTermXrefs::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermXrefs::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermXrefs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermXrefs, 0, sizeof(_ns1__getTermXrefs), 0, soap_copy__ns1__getTermXrefs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId1 > 0 || soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermXrefs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermXrefs);
	if (this->soap_out(soap, tag?tag:"ns1:getTermXrefs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermXrefs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermXrefs(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermXrefs * SOAP_FMAC4 soap_get__ns1__getTermXrefs(struct soap *soap, _ns1__getTermXrefs *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermXrefs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermXrefs * SOAP_FMAC2 soap_instantiate__ns1__getTermXrefs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermXrefs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermXrefs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermXrefs);
		if (size)
			*size = sizeof(_ns1__getTermXrefs);
		((_ns1__getTermXrefs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermXrefs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermXrefs);
		for (int i = 0; i < n; i++)
			((_ns1__getTermXrefs*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermXrefs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermXrefs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermXrefs %p -> %p\n", q, p));
	*(_ns1__getTermXrefs*)p = *(_ns1__getTermXrefs*)q;
}

void _ns1__getTermMetadataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getTermMetadataResponse::getTermMetadataReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getTermMetadataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &this->_ns1__getTermMetadataResponse::getTermMetadataReturn);
	/* transient soap skipped */
}

int _ns1__getTermMetadataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermMetadataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermMetadataResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermMetadataResponse), type))
		return soap->error;
	if (a->getTermMetadataReturn)
		soap_element_result(soap, "ns1:getTermMetadataReturn");
	if (a->_ns1__getTermMetadataResponse::getTermMetadataReturn)
	{	if (soap_out_PointerTons2__Map(soap, "ns1:getTermMetadataReturn", -1, &a->_ns1__getTermMetadataResponse::getTermMetadataReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTermMetadataReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermMetadataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermMetadataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermMetadataResponse * SOAP_FMAC4 soap_in__ns1__getTermMetadataResponse(struct soap *soap, const char *tag, _ns1__getTermMetadataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermMetadataResponse, sizeof(_ns1__getTermMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermMetadataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermMetadataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermMetadataReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermMetadataReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, "ns1:getTermMetadataReturn", &(a->_ns1__getTermMetadataResponse::getTermMetadataReturn), "ns2:Map"))
				{	soap_flag_getTermMetadataReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermMetadataReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermMetadataResponse, 0, sizeof(_ns1__getTermMetadataResponse), 0, soap_copy__ns1__getTermMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermMetadataReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermMetadataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermMetadataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermMetadataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermMetadataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermMetadataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermMetadataResponse * SOAP_FMAC4 soap_get__ns1__getTermMetadataResponse(struct soap *soap, _ns1__getTermMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermMetadataResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermMetadataResponse);
		if (size)
			*size = sizeof(_ns1__getTermMetadataResponse);
		((_ns1__getTermMetadataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermMetadataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermMetadataResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermMetadataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermMetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermMetadataResponse %p -> %p\n", q, p));
	*(_ns1__getTermMetadataResponse*)p = *(_ns1__getTermMetadataResponse*)q;
}

void _ns1__getTermMetadata::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermMetadata::termId);
	soap_default_std__string(soap, &this->_ns1__getTermMetadata::ontologyName);
	/* transient soap skipped */
}

void _ns1__getTermMetadata::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermMetadata::termId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermMetadata::termId);
	soap_embedded(soap, &this->_ns1__getTermMetadata::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermMetadata::ontologyName);
	/* transient soap skipped */
}

int _ns1__getTermMetadata::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermMetadata(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermMetadata(struct soap *soap, const char *tag, int id, const _ns1__getTermMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermMetadata), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:termId", -1, &(a->_ns1__getTermMetadata::termId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermMetadata::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermMetadata::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermMetadata(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermMetadata * SOAP_FMAC4 soap_in__ns1__getTermMetadata(struct soap *soap, const char *tag, _ns1__getTermMetadata *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermMetadata, sizeof(_ns1__getTermMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermMetadata)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermMetadata *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:termId", &(a->_ns1__getTermMetadata::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermMetadata::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermMetadata, 0, sizeof(_ns1__getTermMetadata), 0, soap_copy__ns1__getTermMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId1 > 0 || soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermMetadata::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermMetadata);
	if (this->soap_out(soap, tag?tag:"ns1:getTermMetadata", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermMetadata::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermMetadata(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermMetadata * SOAP_FMAC4 soap_get__ns1__getTermMetadata(struct soap *soap, _ns1__getTermMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermMetadata * SOAP_FMAC2 soap_instantiate__ns1__getTermMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermMetadata);
		if (size)
			*size = sizeof(_ns1__getTermMetadata);
		((_ns1__getTermMetadata*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermMetadata);
		for (int i = 0; i < n; i++)
			((_ns1__getTermMetadata*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermMetadata %p -> %p\n", q, p));
	*(_ns1__getTermMetadata*)p = *(_ns1__getTermMetadata*)q;
}

void _ns1__getTermByIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermByIdResponse::getTermByIdReturn);
	/* transient soap skipped */
}

void _ns1__getTermByIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermByIdResponse::getTermByIdReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermByIdResponse::getTermByIdReturn);
	/* transient soap skipped */
}

int _ns1__getTermByIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermByIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermByIdResponse(struct soap *soap, const char *tag, int id, const _ns1__getTermByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermByIdResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:getTermByIdReturn");
	if (soap_out_std__string(soap, "ns1:getTermByIdReturn", -1, &(a->_ns1__getTermByIdResponse::getTermByIdReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermByIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermByIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermByIdResponse * SOAP_FMAC4 soap_in__ns1__getTermByIdResponse(struct soap *soap, const char *tag, _ns1__getTermByIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermByIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermByIdResponse, sizeof(_ns1__getTermByIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermByIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermByIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTermByIdReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTermByIdReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:getTermByIdReturn", &(a->_ns1__getTermByIdResponse::getTermByIdReturn), "xsd:string"))
				{	soap_flag_getTermByIdReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTermByIdReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermByIdResponse, 0, sizeof(_ns1__getTermByIdResponse), 0, soap_copy__ns1__getTermByIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTermByIdReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermByIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermByIdResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTermByIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermByIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermByIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermByIdResponse * SOAP_FMAC4 soap_get__ns1__getTermByIdResponse(struct soap *soap, _ns1__getTermByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermByIdResponse * SOAP_FMAC2 soap_instantiate__ns1__getTermByIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermByIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermByIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermByIdResponse);
		if (size)
			*size = sizeof(_ns1__getTermByIdResponse);
		((_ns1__getTermByIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermByIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermByIdResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTermByIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermByIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermByIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermByIdResponse %p -> %p\n", q, p));
	*(_ns1__getTermByIdResponse*)p = *(_ns1__getTermByIdResponse*)q;
}

void _ns1__getTermById::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getTermById::termId);
	soap_default_std__string(soap, &this->_ns1__getTermById::ontologyName);
	/* transient soap skipped */
}

void _ns1__getTermById::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getTermById::termId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermById::termId);
	soap_embedded(soap, &this->_ns1__getTermById::ontologyName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getTermById::ontologyName);
	/* transient soap skipped */
}

int _ns1__getTermById::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTermById(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTermById(struct soap *soap, const char *tag, int id, const _ns1__getTermById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTermById), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:termId", -1, &(a->_ns1__getTermById::termId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ontologyName", -1, &(a->_ns1__getTermById::ontologyName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTermById::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTermById(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTermById * SOAP_FMAC4 soap_in__ns1__getTermById(struct soap *soap, const char *tag, _ns1__getTermById *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTermById *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTermById, sizeof(_ns1__getTermById), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTermById)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTermById *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_termId1 = 1;
	size_t soap_flag_ontologyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:termId", &(a->_ns1__getTermById::termId), "xsd:string"))
				{	soap_flag_termId1--;
					continue;
				}
			if (soap_flag_ontologyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ontologyName", &(a->_ns1__getTermById::ontologyName), "xsd:string"))
				{	soap_flag_ontologyName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTermById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTermById, 0, sizeof(_ns1__getTermById), 0, soap_copy__ns1__getTermById);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId1 > 0 || soap_flag_ontologyName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTermById::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTermById);
	if (this->soap_out(soap, tag?tag:"ns1:getTermById", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTermById::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTermById(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTermById * SOAP_FMAC4 soap_get__ns1__getTermById(struct soap *soap, _ns1__getTermById *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTermById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTermById * SOAP_FMAC2 soap_instantiate__ns1__getTermById(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTermById(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTermById, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermById);
		if (size)
			*size = sizeof(_ns1__getTermById);
		((_ns1__getTermById*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTermById[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTermById);
		for (int i = 0; i < n; i++)
			((_ns1__getTermById*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTermById*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTermById(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTermById %p -> %p\n", q, p));
	*(_ns1__getTermById*)p = *(_ns1__getTermById*)q;
}

void _ns1__getVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getVersionResponse::getVersionReturn);
	/* transient soap skipped */
}

void _ns1__getVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getVersionResponse::getVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getVersionResponse::getVersionReturn);
	/* transient soap skipped */
}

int _ns1__getVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVersionResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:getVersionReturn");
	if (soap_out_std__string(soap, "ns1:getVersionReturn", -1, &(a->_ns1__getVersionResponse::getVersionReturn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getVersionResponse * SOAP_FMAC4 soap_in__ns1__getVersionResponse(struct soap *soap, const char *tag, _ns1__getVersionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVersionResponse, sizeof(_ns1__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getVersionReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getVersionReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:getVersionReturn", &(a->_ns1__getVersionResponse::getVersionReturn), "xsd:string"))
				{	soap_flag_getVersionReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getVersionReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVersionResponse, 0, sizeof(_ns1__getVersionResponse), 0, soap_copy__ns1__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getVersionReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getVersionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getVersionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getVersionResponse * SOAP_FMAC4 soap_get__ns1__getVersionResponse(struct soap *soap, _ns1__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getVersionResponse);
		if (size)
			*size = sizeof(_ns1__getVersionResponse);
		((_ns1__getVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getVersionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getVersionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getVersionResponse %p -> %p\n", q, p));
	*(_ns1__getVersionResponse*)p = *(_ns1__getVersionResponse*)q;
}

void _ns1__getVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVersion(struct soap *soap, const char *tag, int id, const _ns1__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVersion), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getVersion * SOAP_FMAC4 soap_in__ns1__getVersion(struct soap *soap, const char *tag, _ns1__getVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVersion, sizeof(_ns1__getVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getVersion *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVersion, 0, sizeof(_ns1__getVersion), 0, soap_copy__ns1__getVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__getVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getVersion);
	if (this->soap_out(soap, tag?tag:"ns1:getVersion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getVersion * SOAP_FMAC4 soap_get__ns1__getVersion(struct soap *soap, _ns1__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getVersion * SOAP_FMAC2 soap_instantiate__ns1__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getVersion);
		if (size)
			*size = sizeof(_ns1__getVersion);
		((_ns1__getVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getVersion);
		for (int i = 0; i < n; i++)
			((_ns1__getVersion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getVersion %p -> %p\n", q, p));
	*(_ns1__getVersion*)p = *(_ns1__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->xsd__string::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string::__item);
	/* transient soap skipped */
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag?tag:"xsd:string", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__string);
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->xsd__int::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag?tag:"xsd:int", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__int);
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__int[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__int);
		for (int i = 0; i < n; i++)
			((xsd__int*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->xsd__double::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__double::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__double::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(a->xsd__double::__item), "xsd:double");
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(a->xsd__double::__item), "xsd:double"))
		return NULL;
	return a;
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (this->soap_out(soap, tag?tag:"xsd:double", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__double);
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__double[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__double);
		for (int i = 0; i < n; i++)
			((xsd__double*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->xsd__boolean::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag?tag:"xsd:boolean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__boolean[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag?tag:"xsd:anyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__boolean[n]);
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__double);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__double[n]);
			if (size)
				*size = n * sizeof(xsd__double);
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__int);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__int[n]);
			if (size)
				*size = n * sizeof(xsd__int);
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__string);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(xsd__string[n]);
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:mapItem"))
	{	cp->type = SOAP_TYPE_ns2__mapItem;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__mapItem);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__mapItem);
			((ns2__mapItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__mapItem[n]);
			if (size)
				*size = n * sizeof(ns2__mapItem);
			for (int i = 0; i < n; i++)
				((ns2__mapItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__mapItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:Map"))
	{	cp->type = SOAP_TYPE_ns2__Map;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__Map);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__Map);
			((ns2__Map*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__Map[n]);
			if (size)
				*size = n * sizeof(ns2__Map);
			for (int i = 0; i < n; i++)
				((ns2__Map*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__Map*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:Vector"))
	{	cp->type = SOAP_TYPE_ns2__Vector;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__Vector);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__Vector);
			((ns2__Vector*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__Vector[n]);
			if (size)
				*size = n * sizeof(ns2__Vector);
			for (int i = 0; i < n; i++)
				((ns2__Vector*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__Vector*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:DataHolder"))
	{	cp->type = SOAP_TYPE_ns3__DataHolder;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__DataHolder);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__DataHolder);
			((ns3__DataHolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns3__DataHolder[n]);
			if (size)
				*size = n * sizeof(ns3__DataHolder);
			for (int i = 0; i < n; i++)
				((ns3__DataHolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__DataHolder*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyType);
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermsByAnnotationData(struct soap *soap, struct __ns1__getTermsByAnnotationData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermsByAnnotationData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermsByAnnotationData(struct soap *soap, const struct __ns1__getTermsByAnnotationData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermsByAnnotationData(soap, &a->ns1__getTermsByAnnotationData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermsByAnnotationData(struct soap *soap, const char *tag, int id, const struct __ns1__getTermsByAnnotationData *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermsByAnnotationData(soap, "ns1:getTermsByAnnotationData", -1, &a->ns1__getTermsByAnnotationData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermsByAnnotationData * SOAP_FMAC4 soap_in___ns1__getTermsByAnnotationData(struct soap *soap, const char *tag, struct __ns1__getTermsByAnnotationData *a, const char *type)
{
	size_t soap_flag_ns1__getTermsByAnnotationData = 1;
	short soap_flag;
	a = (struct __ns1__getTermsByAnnotationData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermsByAnnotationData, sizeof(struct __ns1__getTermsByAnnotationData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermsByAnnotationData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermsByAnnotationData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermsByAnnotationData(soap, "ns1:getTermsByAnnotationData", &a->ns1__getTermsByAnnotationData, ""))
				{	soap_flag_ns1__getTermsByAnnotationData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermsByAnnotationData(struct soap *soap, const struct __ns1__getTermsByAnnotationData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermsByAnnotationData(soap, tag?tag:"-ns1:getTermsByAnnotationData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermsByAnnotationData * SOAP_FMAC4 soap_get___ns1__getTermsByAnnotationData(struct soap *soap, struct __ns1__getTermsByAnnotationData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermsByAnnotationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermsByAnnotationData * SOAP_FMAC2 soap_instantiate___ns1__getTermsByAnnotationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermsByAnnotationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermsByAnnotationData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermsByAnnotationData);
		if (size)
			*size = sizeof(struct __ns1__getTermsByAnnotationData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermsByAnnotationData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermsByAnnotationData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermsByAnnotationData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermsByAnnotationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermsByAnnotationData %p -> %p\n", q, p));
	*(struct __ns1__getTermsByAnnotationData*)p = *(struct __ns1__getTermsByAnnotationData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isObsolete(struct soap *soap, struct __ns1__isObsolete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__isObsolete = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isObsolete(struct soap *soap, const struct __ns1__isObsolete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__isObsolete(soap, &a->ns1__isObsolete);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isObsolete(struct soap *soap, const char *tag, int id, const struct __ns1__isObsolete *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__isObsolete(soap, "ns1:isObsolete", -1, &a->ns1__isObsolete, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isObsolete * SOAP_FMAC4 soap_in___ns1__isObsolete(struct soap *soap, const char *tag, struct __ns1__isObsolete *a, const char *type)
{
	size_t soap_flag_ns1__isObsolete = 1;
	short soap_flag;
	a = (struct __ns1__isObsolete *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isObsolete, sizeof(struct __ns1__isObsolete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isObsolete(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__isObsolete && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__isObsolete(soap, "ns1:isObsolete", &a->ns1__isObsolete, ""))
				{	soap_flag_ns1__isObsolete--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isObsolete(struct soap *soap, const struct __ns1__isObsolete *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isObsolete(soap, tag?tag:"-ns1:isObsolete", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isObsolete * SOAP_FMAC4 soap_get___ns1__isObsolete(struct soap *soap, struct __ns1__isObsolete *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isObsolete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__isObsolete * SOAP_FMAC2 soap_instantiate___ns1__isObsolete(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isObsolete(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isObsolete, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isObsolete);
		if (size)
			*size = sizeof(struct __ns1__isObsolete);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__isObsolete[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__isObsolete);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__isObsolete*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isObsolete(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isObsolete %p -> %p\n", q, p));
	*(struct __ns1__isObsolete*)p = *(struct __ns1__isObsolete*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChildrenFromRoot(struct soap *soap, struct __ns1__getChildrenFromRoot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getChildrenFromRoot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChildrenFromRoot(struct soap *soap, const struct __ns1__getChildrenFromRoot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getChildrenFromRoot(soap, &a->ns1__getChildrenFromRoot);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChildrenFromRoot(struct soap *soap, const char *tag, int id, const struct __ns1__getChildrenFromRoot *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getChildrenFromRoot(soap, "ns1:getChildrenFromRoot", -1, &a->ns1__getChildrenFromRoot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChildrenFromRoot * SOAP_FMAC4 soap_in___ns1__getChildrenFromRoot(struct soap *soap, const char *tag, struct __ns1__getChildrenFromRoot *a, const char *type)
{
	size_t soap_flag_ns1__getChildrenFromRoot = 1;
	short soap_flag;
	a = (struct __ns1__getChildrenFromRoot *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChildrenFromRoot, sizeof(struct __ns1__getChildrenFromRoot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChildrenFromRoot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getChildrenFromRoot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getChildrenFromRoot(soap, "ns1:getChildrenFromRoot", &a->ns1__getChildrenFromRoot, ""))
				{	soap_flag_ns1__getChildrenFromRoot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChildrenFromRoot(struct soap *soap, const struct __ns1__getChildrenFromRoot *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getChildrenFromRoot(soap, tag?tag:"-ns1:getChildrenFromRoot", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChildrenFromRoot * SOAP_FMAC4 soap_get___ns1__getChildrenFromRoot(struct soap *soap, struct __ns1__getChildrenFromRoot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChildrenFromRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getChildrenFromRoot * SOAP_FMAC2 soap_instantiate___ns1__getChildrenFromRoot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getChildrenFromRoot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getChildrenFromRoot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getChildrenFromRoot);
		if (size)
			*size = sizeof(struct __ns1__getChildrenFromRoot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getChildrenFromRoot[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getChildrenFromRoot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getChildrenFromRoot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getChildrenFromRoot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getChildrenFromRoot %p -> %p\n", q, p));
	*(struct __ns1__getChildrenFromRoot*)p = *(struct __ns1__getChildrenFromRoot*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermRelations(struct soap *soap, struct __ns1__getTermRelations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermRelations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermRelations(struct soap *soap, const struct __ns1__getTermRelations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermRelations(soap, &a->ns1__getTermRelations);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermRelations(struct soap *soap, const char *tag, int id, const struct __ns1__getTermRelations *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermRelations(soap, "ns1:getTermRelations", -1, &a->ns1__getTermRelations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermRelations * SOAP_FMAC4 soap_in___ns1__getTermRelations(struct soap *soap, const char *tag, struct __ns1__getTermRelations *a, const char *type)
{
	size_t soap_flag_ns1__getTermRelations = 1;
	short soap_flag;
	a = (struct __ns1__getTermRelations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermRelations, sizeof(struct __ns1__getTermRelations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermRelations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermRelations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermRelations(soap, "ns1:getTermRelations", &a->ns1__getTermRelations, ""))
				{	soap_flag_ns1__getTermRelations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermRelations(struct soap *soap, const struct __ns1__getTermRelations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermRelations(soap, tag?tag:"-ns1:getTermRelations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermRelations * SOAP_FMAC4 soap_get___ns1__getTermRelations(struct soap *soap, struct __ns1__getTermRelations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermRelations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermRelations * SOAP_FMAC2 soap_instantiate___ns1__getTermRelations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermRelations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermRelations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermRelations);
		if (size)
			*size = sizeof(struct __ns1__getTermRelations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermRelations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermRelations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermRelations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermRelations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermRelations %p -> %p\n", q, p));
	*(struct __ns1__getTermRelations*)p = *(struct __ns1__getTermRelations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermChildren(struct soap *soap, struct __ns1__getTermChildren *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermChildren = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermChildren(struct soap *soap, const struct __ns1__getTermChildren *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermChildren(soap, &a->ns1__getTermChildren);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermChildren(struct soap *soap, const char *tag, int id, const struct __ns1__getTermChildren *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermChildren(soap, "ns1:getTermChildren", -1, &a->ns1__getTermChildren, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermChildren * SOAP_FMAC4 soap_in___ns1__getTermChildren(struct soap *soap, const char *tag, struct __ns1__getTermChildren *a, const char *type)
{
	size_t soap_flag_ns1__getTermChildren = 1;
	short soap_flag;
	a = (struct __ns1__getTermChildren *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermChildren, sizeof(struct __ns1__getTermChildren), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermChildren(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermChildren && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermChildren(soap, "ns1:getTermChildren", &a->ns1__getTermChildren, ""))
				{	soap_flag_ns1__getTermChildren--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermChildren(struct soap *soap, const struct __ns1__getTermChildren *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermChildren(soap, tag?tag:"-ns1:getTermChildren", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermChildren * SOAP_FMAC4 soap_get___ns1__getTermChildren(struct soap *soap, struct __ns1__getTermChildren *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermChildren(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermChildren * SOAP_FMAC2 soap_instantiate___ns1__getTermChildren(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermChildren(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermChildren, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermChildren);
		if (size)
			*size = sizeof(struct __ns1__getTermChildren);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermChildren[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermChildren);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermChildren*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermChildren(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermChildren %p -> %p\n", q, p));
	*(struct __ns1__getTermChildren*)p = *(struct __ns1__getTermChildren*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermParents(struct soap *soap, struct __ns1__getTermParents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermParents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermParents(struct soap *soap, const struct __ns1__getTermParents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermParents(soap, &a->ns1__getTermParents);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermParents(struct soap *soap, const char *tag, int id, const struct __ns1__getTermParents *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermParents(soap, "ns1:getTermParents", -1, &a->ns1__getTermParents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermParents * SOAP_FMAC4 soap_in___ns1__getTermParents(struct soap *soap, const char *tag, struct __ns1__getTermParents *a, const char *type)
{
	size_t soap_flag_ns1__getTermParents = 1;
	short soap_flag;
	a = (struct __ns1__getTermParents *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermParents, sizeof(struct __ns1__getTermParents), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermParents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermParents && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermParents(soap, "ns1:getTermParents", &a->ns1__getTermParents, ""))
				{	soap_flag_ns1__getTermParents--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermParents(struct soap *soap, const struct __ns1__getTermParents *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermParents(soap, tag?tag:"-ns1:getTermParents", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermParents * SOAP_FMAC4 soap_get___ns1__getTermParents(struct soap *soap, struct __ns1__getTermParents *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermParents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermParents * SOAP_FMAC2 soap_instantiate___ns1__getTermParents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermParents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermParents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermParents);
		if (size)
			*size = sizeof(struct __ns1__getTermParents);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermParents[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermParents);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermParents*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermParents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermParents %p -> %p\n", q, p));
	*(struct __ns1__getTermParents*)p = *(struct __ns1__getTermParents*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPrefixedTermsByName(struct soap *soap, struct __ns1__getPrefixedTermsByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPrefixedTermsByName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPrefixedTermsByName(struct soap *soap, const struct __ns1__getPrefixedTermsByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPrefixedTermsByName(soap, &a->ns1__getPrefixedTermsByName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPrefixedTermsByName(struct soap *soap, const char *tag, int id, const struct __ns1__getPrefixedTermsByName *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getPrefixedTermsByName(soap, "ns1:getPrefixedTermsByName", -1, &a->ns1__getPrefixedTermsByName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPrefixedTermsByName * SOAP_FMAC4 soap_in___ns1__getPrefixedTermsByName(struct soap *soap, const char *tag, struct __ns1__getPrefixedTermsByName *a, const char *type)
{
	size_t soap_flag_ns1__getPrefixedTermsByName = 1;
	short soap_flag;
	a = (struct __ns1__getPrefixedTermsByName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPrefixedTermsByName, sizeof(struct __ns1__getPrefixedTermsByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPrefixedTermsByName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPrefixedTermsByName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPrefixedTermsByName(soap, "ns1:getPrefixedTermsByName", &a->ns1__getPrefixedTermsByName, ""))
				{	soap_flag_ns1__getPrefixedTermsByName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPrefixedTermsByName(struct soap *soap, const struct __ns1__getPrefixedTermsByName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPrefixedTermsByName(soap, tag?tag:"-ns1:getPrefixedTermsByName", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPrefixedTermsByName * SOAP_FMAC4 soap_get___ns1__getPrefixedTermsByName(struct soap *soap, struct __ns1__getPrefixedTermsByName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPrefixedTermsByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPrefixedTermsByName * SOAP_FMAC2 soap_instantiate___ns1__getPrefixedTermsByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPrefixedTermsByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPrefixedTermsByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPrefixedTermsByName);
		if (size)
			*size = sizeof(struct __ns1__getPrefixedTermsByName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPrefixedTermsByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPrefixedTermsByName);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPrefixedTermsByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPrefixedTermsByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPrefixedTermsByName %p -> %p\n", q, p));
	*(struct __ns1__getPrefixedTermsByName*)p = *(struct __ns1__getPrefixedTermsByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermsByExactName(struct soap *soap, struct __ns1__getTermsByExactName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermsByExactName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermsByExactName(struct soap *soap, const struct __ns1__getTermsByExactName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermsByExactName(soap, &a->ns1__getTermsByExactName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermsByExactName(struct soap *soap, const char *tag, int id, const struct __ns1__getTermsByExactName *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermsByExactName(soap, "ns1:getTermsByExactName", -1, &a->ns1__getTermsByExactName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermsByExactName * SOAP_FMAC4 soap_in___ns1__getTermsByExactName(struct soap *soap, const char *tag, struct __ns1__getTermsByExactName *a, const char *type)
{
	size_t soap_flag_ns1__getTermsByExactName = 1;
	short soap_flag;
	a = (struct __ns1__getTermsByExactName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermsByExactName, sizeof(struct __ns1__getTermsByExactName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermsByExactName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermsByExactName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermsByExactName(soap, "ns1:getTermsByExactName", &a->ns1__getTermsByExactName, ""))
				{	soap_flag_ns1__getTermsByExactName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermsByExactName(struct soap *soap, const struct __ns1__getTermsByExactName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermsByExactName(soap, tag?tag:"-ns1:getTermsByExactName", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermsByExactName * SOAP_FMAC4 soap_get___ns1__getTermsByExactName(struct soap *soap, struct __ns1__getTermsByExactName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermsByExactName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermsByExactName * SOAP_FMAC2 soap_instantiate___ns1__getTermsByExactName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermsByExactName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermsByExactName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermsByExactName);
		if (size)
			*size = sizeof(struct __ns1__getTermsByExactName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermsByExactName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermsByExactName);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermsByExactName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermsByExactName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermsByExactName %p -> %p\n", q, p));
	*(struct __ns1__getTermsByExactName*)p = *(struct __ns1__getTermsByExactName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermsByName(struct soap *soap, struct __ns1__getTermsByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermsByName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermsByName(struct soap *soap, const struct __ns1__getTermsByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermsByName(soap, &a->ns1__getTermsByName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermsByName(struct soap *soap, const char *tag, int id, const struct __ns1__getTermsByName *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermsByName(soap, "ns1:getTermsByName", -1, &a->ns1__getTermsByName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermsByName * SOAP_FMAC4 soap_in___ns1__getTermsByName(struct soap *soap, const char *tag, struct __ns1__getTermsByName *a, const char *type)
{
	size_t soap_flag_ns1__getTermsByName = 1;
	short soap_flag;
	a = (struct __ns1__getTermsByName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermsByName, sizeof(struct __ns1__getTermsByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermsByName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermsByName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermsByName(soap, "ns1:getTermsByName", &a->ns1__getTermsByName, ""))
				{	soap_flag_ns1__getTermsByName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermsByName(struct soap *soap, const struct __ns1__getTermsByName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermsByName(soap, tag?tag:"-ns1:getTermsByName", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermsByName * SOAP_FMAC4 soap_get___ns1__getTermsByName(struct soap *soap, struct __ns1__getTermsByName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermsByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermsByName * SOAP_FMAC2 soap_instantiate___ns1__getTermsByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermsByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermsByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermsByName);
		if (size)
			*size = sizeof(struct __ns1__getTermsByName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermsByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermsByName);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermsByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermsByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermsByName %p -> %p\n", q, p));
	*(struct __ns1__getTermsByName*)p = *(struct __ns1__getTermsByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRootTerms(struct soap *soap, struct __ns1__getRootTerms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRootTerms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRootTerms(struct soap *soap, const struct __ns1__getRootTerms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getRootTerms(soap, &a->ns1__getRootTerms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRootTerms(struct soap *soap, const char *tag, int id, const struct __ns1__getRootTerms *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getRootTerms(soap, "ns1:getRootTerms", -1, &a->ns1__getRootTerms, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRootTerms * SOAP_FMAC4 soap_in___ns1__getRootTerms(struct soap *soap, const char *tag, struct __ns1__getRootTerms *a, const char *type)
{
	size_t soap_flag_ns1__getRootTerms = 1;
	short soap_flag;
	a = (struct __ns1__getRootTerms *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRootTerms, sizeof(struct __ns1__getRootTerms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRootTerms(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRootTerms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getRootTerms(soap, "ns1:getRootTerms", &a->ns1__getRootTerms, ""))
				{	soap_flag_ns1__getRootTerms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRootTerms(struct soap *soap, const struct __ns1__getRootTerms *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRootTerms(soap, tag?tag:"-ns1:getRootTerms", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRootTerms * SOAP_FMAC4 soap_get___ns1__getRootTerms(struct soap *soap, struct __ns1__getRootTerms *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRootTerms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getRootTerms * SOAP_FMAC2 soap_instantiate___ns1__getRootTerms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRootTerms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getRootTerms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRootTerms);
		if (size)
			*size = sizeof(struct __ns1__getRootTerms);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRootTerms[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getRootTerms);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getRootTerms*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRootTerms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRootTerms %p -> %p\n", q, p));
	*(struct __ns1__getRootTerms*)p = *(struct __ns1__getRootTerms*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllTermsFromOntology(struct soap *soap, struct __ns1__getAllTermsFromOntology *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllTermsFromOntology = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllTermsFromOntology(struct soap *soap, const struct __ns1__getAllTermsFromOntology *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllTermsFromOntology(soap, &a->ns1__getAllTermsFromOntology);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllTermsFromOntology(struct soap *soap, const char *tag, int id, const struct __ns1__getAllTermsFromOntology *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllTermsFromOntology(soap, "ns1:getAllTermsFromOntology", -1, &a->ns1__getAllTermsFromOntology, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllTermsFromOntology * SOAP_FMAC4 soap_in___ns1__getAllTermsFromOntology(struct soap *soap, const char *tag, struct __ns1__getAllTermsFromOntology *a, const char *type)
{
	size_t soap_flag_ns1__getAllTermsFromOntology = 1;
	short soap_flag;
	a = (struct __ns1__getAllTermsFromOntology *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllTermsFromOntology, sizeof(struct __ns1__getAllTermsFromOntology), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllTermsFromOntology(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllTermsFromOntology && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllTermsFromOntology(soap, "ns1:getAllTermsFromOntology", &a->ns1__getAllTermsFromOntology, ""))
				{	soap_flag_ns1__getAllTermsFromOntology--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllTermsFromOntology(struct soap *soap, const struct __ns1__getAllTermsFromOntology *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllTermsFromOntology(soap, tag?tag:"-ns1:getAllTermsFromOntology", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllTermsFromOntology * SOAP_FMAC4 soap_get___ns1__getAllTermsFromOntology(struct soap *soap, struct __ns1__getAllTermsFromOntology *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllTermsFromOntology(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAllTermsFromOntology * SOAP_FMAC2 soap_instantiate___ns1__getAllTermsFromOntology(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAllTermsFromOntology(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAllTermsFromOntology, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllTermsFromOntology);
		if (size)
			*size = sizeof(struct __ns1__getAllTermsFromOntology);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAllTermsFromOntology[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAllTermsFromOntology);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAllTermsFromOntology*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAllTermsFromOntology(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAllTermsFromOntology %p -> %p\n", q, p));
	*(struct __ns1__getAllTermsFromOntology*)p = *(struct __ns1__getAllTermsFromOntology*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOntologyLoadDate(struct soap *soap, struct __ns1__getOntologyLoadDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getOntologyLoadDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOntologyLoadDate(struct soap *soap, const struct __ns1__getOntologyLoadDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getOntologyLoadDate(soap, &a->ns1__getOntologyLoadDate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOntologyLoadDate(struct soap *soap, const char *tag, int id, const struct __ns1__getOntologyLoadDate *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getOntologyLoadDate(soap, "ns1:getOntologyLoadDate", -1, &a->ns1__getOntologyLoadDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOntologyLoadDate * SOAP_FMAC4 soap_in___ns1__getOntologyLoadDate(struct soap *soap, const char *tag, struct __ns1__getOntologyLoadDate *a, const char *type)
{
	size_t soap_flag_ns1__getOntologyLoadDate = 1;
	short soap_flag;
	a = (struct __ns1__getOntologyLoadDate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOntologyLoadDate, sizeof(struct __ns1__getOntologyLoadDate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOntologyLoadDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getOntologyLoadDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getOntologyLoadDate(soap, "ns1:getOntologyLoadDate", &a->ns1__getOntologyLoadDate, ""))
				{	soap_flag_ns1__getOntologyLoadDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOntologyLoadDate(struct soap *soap, const struct __ns1__getOntologyLoadDate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getOntologyLoadDate(soap, tag?tag:"-ns1:getOntologyLoadDate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOntologyLoadDate * SOAP_FMAC4 soap_get___ns1__getOntologyLoadDate(struct soap *soap, struct __ns1__getOntologyLoadDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOntologyLoadDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getOntologyLoadDate * SOAP_FMAC2 soap_instantiate___ns1__getOntologyLoadDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getOntologyLoadDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getOntologyLoadDate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getOntologyLoadDate);
		if (size)
			*size = sizeof(struct __ns1__getOntologyLoadDate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getOntologyLoadDate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getOntologyLoadDate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getOntologyLoadDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getOntologyLoadDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getOntologyLoadDate %p -> %p\n", q, p));
	*(struct __ns1__getOntologyLoadDate*)p = *(struct __ns1__getOntologyLoadDate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOntologyNames(struct soap *soap, struct __ns1__getOntologyNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getOntologyNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOntologyNames(struct soap *soap, const struct __ns1__getOntologyNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getOntologyNames(soap, &a->ns1__getOntologyNames);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOntologyNames(struct soap *soap, const char *tag, int id, const struct __ns1__getOntologyNames *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getOntologyNames(soap, "ns1:getOntologyNames", -1, &a->ns1__getOntologyNames, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOntologyNames * SOAP_FMAC4 soap_in___ns1__getOntologyNames(struct soap *soap, const char *tag, struct __ns1__getOntologyNames *a, const char *type)
{
	size_t soap_flag_ns1__getOntologyNames = 1;
	short soap_flag;
	a = (struct __ns1__getOntologyNames *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOntologyNames, sizeof(struct __ns1__getOntologyNames), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOntologyNames(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getOntologyNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getOntologyNames(soap, "ns1:getOntologyNames", &a->ns1__getOntologyNames, ""))
				{	soap_flag_ns1__getOntologyNames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOntologyNames(struct soap *soap, const struct __ns1__getOntologyNames *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getOntologyNames(soap, tag?tag:"-ns1:getOntologyNames", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOntologyNames * SOAP_FMAC4 soap_get___ns1__getOntologyNames(struct soap *soap, struct __ns1__getOntologyNames *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOntologyNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getOntologyNames * SOAP_FMAC2 soap_instantiate___ns1__getOntologyNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getOntologyNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getOntologyNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getOntologyNames);
		if (size)
			*size = sizeof(struct __ns1__getOntologyNames);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getOntologyNames[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getOntologyNames);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getOntologyNames*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getOntologyNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getOntologyNames %p -> %p\n", q, p));
	*(struct __ns1__getOntologyNames*)p = *(struct __ns1__getOntologyNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermXrefs(struct soap *soap, struct __ns1__getTermXrefs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermXrefs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermXrefs(struct soap *soap, const struct __ns1__getTermXrefs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermXrefs(soap, &a->ns1__getTermXrefs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermXrefs(struct soap *soap, const char *tag, int id, const struct __ns1__getTermXrefs *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermXrefs(soap, "ns1:getTermXrefs", -1, &a->ns1__getTermXrefs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermXrefs * SOAP_FMAC4 soap_in___ns1__getTermXrefs(struct soap *soap, const char *tag, struct __ns1__getTermXrefs *a, const char *type)
{
	size_t soap_flag_ns1__getTermXrefs = 1;
	short soap_flag;
	a = (struct __ns1__getTermXrefs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermXrefs, sizeof(struct __ns1__getTermXrefs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermXrefs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermXrefs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermXrefs(soap, "ns1:getTermXrefs", &a->ns1__getTermXrefs, ""))
				{	soap_flag_ns1__getTermXrefs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermXrefs(struct soap *soap, const struct __ns1__getTermXrefs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermXrefs(soap, tag?tag:"-ns1:getTermXrefs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermXrefs * SOAP_FMAC4 soap_get___ns1__getTermXrefs(struct soap *soap, struct __ns1__getTermXrefs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermXrefs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermXrefs * SOAP_FMAC2 soap_instantiate___ns1__getTermXrefs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermXrefs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermXrefs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermXrefs);
		if (size)
			*size = sizeof(struct __ns1__getTermXrefs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermXrefs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermXrefs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermXrefs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermXrefs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermXrefs %p -> %p\n", q, p));
	*(struct __ns1__getTermXrefs*)p = *(struct __ns1__getTermXrefs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermMetadata(struct soap *soap, struct __ns1__getTermMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermMetadata = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermMetadata(struct soap *soap, const struct __ns1__getTermMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermMetadata(soap, &a->ns1__getTermMetadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermMetadata(struct soap *soap, const char *tag, int id, const struct __ns1__getTermMetadata *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermMetadata(soap, "ns1:getTermMetadata", -1, &a->ns1__getTermMetadata, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermMetadata * SOAP_FMAC4 soap_in___ns1__getTermMetadata(struct soap *soap, const char *tag, struct __ns1__getTermMetadata *a, const char *type)
{
	size_t soap_flag_ns1__getTermMetadata = 1;
	short soap_flag;
	a = (struct __ns1__getTermMetadata *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermMetadata, sizeof(struct __ns1__getTermMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermMetadata(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermMetadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermMetadata(soap, "ns1:getTermMetadata", &a->ns1__getTermMetadata, ""))
				{	soap_flag_ns1__getTermMetadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermMetadata(struct soap *soap, const struct __ns1__getTermMetadata *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermMetadata(soap, tag?tag:"-ns1:getTermMetadata", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermMetadata * SOAP_FMAC4 soap_get___ns1__getTermMetadata(struct soap *soap, struct __ns1__getTermMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermMetadata * SOAP_FMAC2 soap_instantiate___ns1__getTermMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermMetadata);
		if (size)
			*size = sizeof(struct __ns1__getTermMetadata);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermMetadata);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermMetadata %p -> %p\n", q, p));
	*(struct __ns1__getTermMetadata*)p = *(struct __ns1__getTermMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTermById(struct soap *soap, struct __ns1__getTermById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTermById = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTermById(struct soap *soap, const struct __ns1__getTermById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTermById(soap, &a->ns1__getTermById);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTermById(struct soap *soap, const char *tag, int id, const struct __ns1__getTermById *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTermById(soap, "ns1:getTermById", -1, &a->ns1__getTermById, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermById * SOAP_FMAC4 soap_in___ns1__getTermById(struct soap *soap, const char *tag, struct __ns1__getTermById *a, const char *type)
{
	size_t soap_flag_ns1__getTermById = 1;
	short soap_flag;
	a = (struct __ns1__getTermById *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTermById, sizeof(struct __ns1__getTermById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTermById(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTermById && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTermById(soap, "ns1:getTermById", &a->ns1__getTermById, ""))
				{	soap_flag_ns1__getTermById--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTermById(struct soap *soap, const struct __ns1__getTermById *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTermById(soap, tag?tag:"-ns1:getTermById", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTermById * SOAP_FMAC4 soap_get___ns1__getTermById(struct soap *soap, struct __ns1__getTermById *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTermById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTermById * SOAP_FMAC2 soap_instantiate___ns1__getTermById(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTermById(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTermById, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermById);
		if (size)
			*size = sizeof(struct __ns1__getTermById);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTermById[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getTermById);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getTermById*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTermById(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTermById %p -> %p\n", q, p));
	*(struct __ns1__getTermById*)p = *(struct __ns1__getTermById*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVersion(struct soap *soap, struct __ns1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVersion(struct soap *soap, const struct __ns1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getVersion(soap, &a->ns1__getVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVersion(struct soap *soap, const char *tag, int id, const struct __ns1__getVersion *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getVersion(soap, "ns1:getVersion", -1, &a->ns1__getVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVersion * SOAP_FMAC4 soap_in___ns1__getVersion(struct soap *soap, const char *tag, struct __ns1__getVersion *a, const char *type)
{
	size_t soap_flag_ns1__getVersion = 1;
	short soap_flag;
	a = (struct __ns1__getVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVersion, sizeof(struct __ns1__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getVersion(soap, "ns1:getVersion", &a->ns1__getVersion, ""))
				{	soap_flag_ns1__getVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVersion(struct soap *soap, const struct __ns1__getVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVersion(soap, tag?tag:"-ns1:getVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVersion * SOAP_FMAC4 soap_get___ns1__getVersion(struct soap *soap, struct __ns1__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getVersion * SOAP_FMAC2 soap_instantiate___ns1__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getVersion);
		if (size)
			*size = sizeof(struct __ns1__getVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getVersion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getVersion %p -> %p\n", q, p));
	*(struct __ns1__getVersion*)p = *(struct __ns1__getVersion*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermsByAnnotationDataResponse(struct soap *soap, _ns1__getTermsByAnnotationDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermsByAnnotationDataResponse(struct soap *soap, const char *tag, int id, _ns1__getTermsByAnnotationDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationDataResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermsByAnnotationDataResponse(struct soap *soap, const char *tag, _ns1__getTermsByAnnotationDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermsByAnnotationDataResponse **)soap_malloc(soap, sizeof(_ns1__getTermsByAnnotationDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermsByAnnotationDataResponse *)soap_instantiate__ns1__getTermsByAnnotationDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermsByAnnotationDataResponse ** p = (_ns1__getTermsByAnnotationDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermsByAnnotationDataResponse, sizeof(_ns1__getTermsByAnnotationDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermsByAnnotationDataResponse(struct soap *soap, _ns1__getTermsByAnnotationDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationDataResponse);
	if (soap_out_PointerTo_ns1__getTermsByAnnotationDataResponse(soap, tag?tag:"ns1:getTermsByAnnotationDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationDataResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermsByAnnotationDataResponse(struct soap *soap, _ns1__getTermsByAnnotationDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermsByAnnotationDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermsByAnnotationData(struct soap *soap, _ns1__getTermsByAnnotationData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermsByAnnotationData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermsByAnnotationData(struct soap *soap, const char *tag, int id, _ns1__getTermsByAnnotationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermsByAnnotationData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationData ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermsByAnnotationData(struct soap *soap, const char *tag, _ns1__getTermsByAnnotationData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermsByAnnotationData **)soap_malloc(soap, sizeof(_ns1__getTermsByAnnotationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermsByAnnotationData *)soap_instantiate__ns1__getTermsByAnnotationData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermsByAnnotationData ** p = (_ns1__getTermsByAnnotationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermsByAnnotationData, sizeof(_ns1__getTermsByAnnotationData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermsByAnnotationData(struct soap *soap, _ns1__getTermsByAnnotationData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermsByAnnotationData);
	if (soap_out_PointerTo_ns1__getTermsByAnnotationData(soap, tag?tag:"ns1:getTermsByAnnotationData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermsByAnnotationData ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermsByAnnotationData(struct soap *soap, _ns1__getTermsByAnnotationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermsByAnnotationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__isObsoleteResponse(struct soap *soap, _ns1__isObsoleteResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__isObsoleteResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__isObsoleteResponse(struct soap *soap, const char *tag, int id, _ns1__isObsoleteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__isObsoleteResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__isObsoleteResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__isObsoleteResponse(struct soap *soap, const char *tag, _ns1__isObsoleteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__isObsoleteResponse **)soap_malloc(soap, sizeof(_ns1__isObsoleteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__isObsoleteResponse *)soap_instantiate__ns1__isObsoleteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__isObsoleteResponse ** p = (_ns1__isObsoleteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__isObsoleteResponse, sizeof(_ns1__isObsoleteResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__isObsoleteResponse(struct soap *soap, _ns1__isObsoleteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__isObsoleteResponse);
	if (soap_out_PointerTo_ns1__isObsoleteResponse(soap, tag?tag:"ns1:isObsoleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__isObsoleteResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__isObsoleteResponse(struct soap *soap, _ns1__isObsoleteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__isObsoleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__isObsolete(struct soap *soap, _ns1__isObsolete *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__isObsolete))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__isObsolete(struct soap *soap, const char *tag, int id, _ns1__isObsolete *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__isObsolete);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__isObsolete ** SOAP_FMAC4 soap_in_PointerTo_ns1__isObsolete(struct soap *soap, const char *tag, _ns1__isObsolete **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__isObsolete **)soap_malloc(soap, sizeof(_ns1__isObsolete *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__isObsolete *)soap_instantiate__ns1__isObsolete(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__isObsolete ** p = (_ns1__isObsolete **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__isObsolete, sizeof(_ns1__isObsolete), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__isObsolete(struct soap *soap, _ns1__isObsolete *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__isObsolete);
	if (soap_out_PointerTo_ns1__isObsolete(soap, tag?tag:"ns1:isObsolete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__isObsolete ** SOAP_FMAC4 soap_get_PointerTo_ns1__isObsolete(struct soap *soap, _ns1__isObsolete **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__isObsolete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChildrenFromRootResponse(struct soap *soap, _ns1__getChildrenFromRootResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChildrenFromRootResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChildrenFromRootResponse(struct soap *soap, const char *tag, int id, _ns1__getChildrenFromRootResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChildrenFromRootResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getChildrenFromRootResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChildrenFromRootResponse(struct soap *soap, const char *tag, _ns1__getChildrenFromRootResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getChildrenFromRootResponse **)soap_malloc(soap, sizeof(_ns1__getChildrenFromRootResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getChildrenFromRootResponse *)soap_instantiate__ns1__getChildrenFromRootResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getChildrenFromRootResponse ** p = (_ns1__getChildrenFromRootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChildrenFromRootResponse, sizeof(_ns1__getChildrenFromRootResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChildrenFromRootResponse(struct soap *soap, _ns1__getChildrenFromRootResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChildrenFromRootResponse);
	if (soap_out_PointerTo_ns1__getChildrenFromRootResponse(soap, tag?tag:"ns1:getChildrenFromRootResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getChildrenFromRootResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChildrenFromRootResponse(struct soap *soap, _ns1__getChildrenFromRootResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChildrenFromRootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChildrenFromRoot(struct soap *soap, _ns1__getChildrenFromRoot *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChildrenFromRoot))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChildrenFromRoot(struct soap *soap, const char *tag, int id, _ns1__getChildrenFromRoot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChildrenFromRoot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getChildrenFromRoot ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChildrenFromRoot(struct soap *soap, const char *tag, _ns1__getChildrenFromRoot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getChildrenFromRoot **)soap_malloc(soap, sizeof(_ns1__getChildrenFromRoot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getChildrenFromRoot *)soap_instantiate__ns1__getChildrenFromRoot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getChildrenFromRoot ** p = (_ns1__getChildrenFromRoot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChildrenFromRoot, sizeof(_ns1__getChildrenFromRoot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChildrenFromRoot(struct soap *soap, _ns1__getChildrenFromRoot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChildrenFromRoot);
	if (soap_out_PointerTo_ns1__getChildrenFromRoot(soap, tag?tag:"ns1:getChildrenFromRoot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getChildrenFromRoot ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChildrenFromRoot(struct soap *soap, _ns1__getChildrenFromRoot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChildrenFromRoot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermRelationsResponse(struct soap *soap, _ns1__getTermRelationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermRelationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermRelationsResponse(struct soap *soap, const char *tag, int id, _ns1__getTermRelationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermRelationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermRelationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermRelationsResponse(struct soap *soap, const char *tag, _ns1__getTermRelationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermRelationsResponse **)soap_malloc(soap, sizeof(_ns1__getTermRelationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermRelationsResponse *)soap_instantiate__ns1__getTermRelationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermRelationsResponse ** p = (_ns1__getTermRelationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermRelationsResponse, sizeof(_ns1__getTermRelationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermRelationsResponse(struct soap *soap, _ns1__getTermRelationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermRelationsResponse);
	if (soap_out_PointerTo_ns1__getTermRelationsResponse(soap, tag?tag:"ns1:getTermRelationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermRelationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermRelationsResponse(struct soap *soap, _ns1__getTermRelationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermRelationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermRelations(struct soap *soap, _ns1__getTermRelations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermRelations))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermRelations(struct soap *soap, const char *tag, int id, _ns1__getTermRelations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermRelations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermRelations ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermRelations(struct soap *soap, const char *tag, _ns1__getTermRelations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermRelations **)soap_malloc(soap, sizeof(_ns1__getTermRelations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermRelations *)soap_instantiate__ns1__getTermRelations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermRelations ** p = (_ns1__getTermRelations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermRelations, sizeof(_ns1__getTermRelations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermRelations(struct soap *soap, _ns1__getTermRelations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermRelations);
	if (soap_out_PointerTo_ns1__getTermRelations(soap, tag?tag:"ns1:getTermRelations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermRelations ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermRelations(struct soap *soap, _ns1__getTermRelations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermRelations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermChildrenResponse(struct soap *soap, _ns1__getTermChildrenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermChildrenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermChildrenResponse(struct soap *soap, const char *tag, int id, _ns1__getTermChildrenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermChildrenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermChildrenResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermChildrenResponse(struct soap *soap, const char *tag, _ns1__getTermChildrenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermChildrenResponse **)soap_malloc(soap, sizeof(_ns1__getTermChildrenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermChildrenResponse *)soap_instantiate__ns1__getTermChildrenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermChildrenResponse ** p = (_ns1__getTermChildrenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermChildrenResponse, sizeof(_ns1__getTermChildrenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermChildrenResponse(struct soap *soap, _ns1__getTermChildrenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermChildrenResponse);
	if (soap_out_PointerTo_ns1__getTermChildrenResponse(soap, tag?tag:"ns1:getTermChildrenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermChildrenResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermChildrenResponse(struct soap *soap, _ns1__getTermChildrenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermChildrenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermChildren(struct soap *soap, _ns1__getTermChildren *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermChildren))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermChildren(struct soap *soap, const char *tag, int id, _ns1__getTermChildren *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermChildren);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermChildren ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermChildren(struct soap *soap, const char *tag, _ns1__getTermChildren **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermChildren **)soap_malloc(soap, sizeof(_ns1__getTermChildren *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermChildren *)soap_instantiate__ns1__getTermChildren(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermChildren ** p = (_ns1__getTermChildren **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermChildren, sizeof(_ns1__getTermChildren), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermChildren(struct soap *soap, _ns1__getTermChildren *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermChildren);
	if (soap_out_PointerTo_ns1__getTermChildren(soap, tag?tag:"ns1:getTermChildren", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermChildren ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermChildren(struct soap *soap, _ns1__getTermChildren **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermChildren(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermParentsResponse(struct soap *soap, _ns1__getTermParentsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermParentsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermParentsResponse(struct soap *soap, const char *tag, int id, _ns1__getTermParentsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermParentsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermParentsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermParentsResponse(struct soap *soap, const char *tag, _ns1__getTermParentsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermParentsResponse **)soap_malloc(soap, sizeof(_ns1__getTermParentsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermParentsResponse *)soap_instantiate__ns1__getTermParentsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermParentsResponse ** p = (_ns1__getTermParentsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermParentsResponse, sizeof(_ns1__getTermParentsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermParentsResponse(struct soap *soap, _ns1__getTermParentsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermParentsResponse);
	if (soap_out_PointerTo_ns1__getTermParentsResponse(soap, tag?tag:"ns1:getTermParentsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermParentsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermParentsResponse(struct soap *soap, _ns1__getTermParentsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermParentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermParents(struct soap *soap, _ns1__getTermParents *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermParents))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermParents(struct soap *soap, const char *tag, int id, _ns1__getTermParents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermParents);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermParents ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermParents(struct soap *soap, const char *tag, _ns1__getTermParents **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermParents **)soap_malloc(soap, sizeof(_ns1__getTermParents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermParents *)soap_instantiate__ns1__getTermParents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermParents ** p = (_ns1__getTermParents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermParents, sizeof(_ns1__getTermParents), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermParents(struct soap *soap, _ns1__getTermParents *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermParents);
	if (soap_out_PointerTo_ns1__getTermParents(soap, tag?tag:"ns1:getTermParents", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermParents ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermParents(struct soap *soap, _ns1__getTermParents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermParents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrefixedTermsByNameResponse(struct soap *soap, _ns1__getPrefixedTermsByNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrefixedTermsByNameResponse(struct soap *soap, const char *tag, int id, _ns1__getPrefixedTermsByNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByNameResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrefixedTermsByNameResponse(struct soap *soap, const char *tag, _ns1__getPrefixedTermsByNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPrefixedTermsByNameResponse **)soap_malloc(soap, sizeof(_ns1__getPrefixedTermsByNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPrefixedTermsByNameResponse *)soap_instantiate__ns1__getPrefixedTermsByNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getPrefixedTermsByNameResponse ** p = (_ns1__getPrefixedTermsByNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrefixedTermsByNameResponse, sizeof(_ns1__getPrefixedTermsByNameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrefixedTermsByNameResponse(struct soap *soap, _ns1__getPrefixedTermsByNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByNameResponse);
	if (soap_out_PointerTo_ns1__getPrefixedTermsByNameResponse(soap, tag?tag:"ns1:getPrefixedTermsByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByNameResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrefixedTermsByNameResponse(struct soap *soap, _ns1__getPrefixedTermsByNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrefixedTermsByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrefixedTermsByName(struct soap *soap, _ns1__getPrefixedTermsByName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrefixedTermsByName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrefixedTermsByName(struct soap *soap, const char *tag, int id, _ns1__getPrefixedTermsByName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrefixedTermsByName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByName ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrefixedTermsByName(struct soap *soap, const char *tag, _ns1__getPrefixedTermsByName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPrefixedTermsByName **)soap_malloc(soap, sizeof(_ns1__getPrefixedTermsByName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPrefixedTermsByName *)soap_instantiate__ns1__getPrefixedTermsByName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getPrefixedTermsByName ** p = (_ns1__getPrefixedTermsByName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrefixedTermsByName, sizeof(_ns1__getPrefixedTermsByName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrefixedTermsByName(struct soap *soap, _ns1__getPrefixedTermsByName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrefixedTermsByName);
	if (soap_out_PointerTo_ns1__getPrefixedTermsByName(soap, tag?tag:"ns1:getPrefixedTermsByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPrefixedTermsByName ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrefixedTermsByName(struct soap *soap, _ns1__getPrefixedTermsByName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrefixedTermsByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermsByExactNameResponse(struct soap *soap, _ns1__getTermsByExactNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermsByExactNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermsByExactNameResponse(struct soap *soap, const char *tag, int id, _ns1__getTermsByExactNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermsByExactNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermsByExactNameResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermsByExactNameResponse(struct soap *soap, const char *tag, _ns1__getTermsByExactNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermsByExactNameResponse **)soap_malloc(soap, sizeof(_ns1__getTermsByExactNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermsByExactNameResponse *)soap_instantiate__ns1__getTermsByExactNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermsByExactNameResponse ** p = (_ns1__getTermsByExactNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermsByExactNameResponse, sizeof(_ns1__getTermsByExactNameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermsByExactNameResponse(struct soap *soap, _ns1__getTermsByExactNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermsByExactNameResponse);
	if (soap_out_PointerTo_ns1__getTermsByExactNameResponse(soap, tag?tag:"ns1:getTermsByExactNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermsByExactNameResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermsByExactNameResponse(struct soap *soap, _ns1__getTermsByExactNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermsByExactNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermsByExactName(struct soap *soap, _ns1__getTermsByExactName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermsByExactName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermsByExactName(struct soap *soap, const char *tag, int id, _ns1__getTermsByExactName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermsByExactName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermsByExactName ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermsByExactName(struct soap *soap, const char *tag, _ns1__getTermsByExactName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermsByExactName **)soap_malloc(soap, sizeof(_ns1__getTermsByExactName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermsByExactName *)soap_instantiate__ns1__getTermsByExactName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermsByExactName ** p = (_ns1__getTermsByExactName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermsByExactName, sizeof(_ns1__getTermsByExactName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermsByExactName(struct soap *soap, _ns1__getTermsByExactName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermsByExactName);
	if (soap_out_PointerTo_ns1__getTermsByExactName(soap, tag?tag:"ns1:getTermsByExactName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermsByExactName ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermsByExactName(struct soap *soap, _ns1__getTermsByExactName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermsByExactName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermsByNameResponse(struct soap *soap, _ns1__getTermsByNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermsByNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermsByNameResponse(struct soap *soap, const char *tag, int id, _ns1__getTermsByNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermsByNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermsByNameResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermsByNameResponse(struct soap *soap, const char *tag, _ns1__getTermsByNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermsByNameResponse **)soap_malloc(soap, sizeof(_ns1__getTermsByNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermsByNameResponse *)soap_instantiate__ns1__getTermsByNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermsByNameResponse ** p = (_ns1__getTermsByNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermsByNameResponse, sizeof(_ns1__getTermsByNameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermsByNameResponse(struct soap *soap, _ns1__getTermsByNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermsByNameResponse);
	if (soap_out_PointerTo_ns1__getTermsByNameResponse(soap, tag?tag:"ns1:getTermsByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermsByNameResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermsByNameResponse(struct soap *soap, _ns1__getTermsByNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermsByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermsByName(struct soap *soap, _ns1__getTermsByName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermsByName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermsByName(struct soap *soap, const char *tag, int id, _ns1__getTermsByName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermsByName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermsByName ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermsByName(struct soap *soap, const char *tag, _ns1__getTermsByName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermsByName **)soap_malloc(soap, sizeof(_ns1__getTermsByName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermsByName *)soap_instantiate__ns1__getTermsByName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermsByName ** p = (_ns1__getTermsByName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermsByName, sizeof(_ns1__getTermsByName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermsByName(struct soap *soap, _ns1__getTermsByName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermsByName);
	if (soap_out_PointerTo_ns1__getTermsByName(soap, tag?tag:"ns1:getTermsByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermsByName ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermsByName(struct soap *soap, _ns1__getTermsByName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermsByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRootTermsResponse(struct soap *soap, _ns1__getRootTermsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRootTermsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRootTermsResponse(struct soap *soap, const char *tag, int id, _ns1__getRootTermsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRootTermsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRootTermsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRootTermsResponse(struct soap *soap, const char *tag, _ns1__getRootTermsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRootTermsResponse **)soap_malloc(soap, sizeof(_ns1__getRootTermsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRootTermsResponse *)soap_instantiate__ns1__getRootTermsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRootTermsResponse ** p = (_ns1__getRootTermsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRootTermsResponse, sizeof(_ns1__getRootTermsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRootTermsResponse(struct soap *soap, _ns1__getRootTermsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRootTermsResponse);
	if (soap_out_PointerTo_ns1__getRootTermsResponse(soap, tag?tag:"ns1:getRootTermsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRootTermsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRootTermsResponse(struct soap *soap, _ns1__getRootTermsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRootTermsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRootTerms(struct soap *soap, _ns1__getRootTerms *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRootTerms))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRootTerms(struct soap *soap, const char *tag, int id, _ns1__getRootTerms *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRootTerms);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRootTerms ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRootTerms(struct soap *soap, const char *tag, _ns1__getRootTerms **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRootTerms **)soap_malloc(soap, sizeof(_ns1__getRootTerms *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRootTerms *)soap_instantiate__ns1__getRootTerms(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRootTerms ** p = (_ns1__getRootTerms **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRootTerms, sizeof(_ns1__getRootTerms), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRootTerms(struct soap *soap, _ns1__getRootTerms *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRootTerms);
	if (soap_out_PointerTo_ns1__getRootTerms(soap, tag?tag:"ns1:getRootTerms", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRootTerms ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRootTerms(struct soap *soap, _ns1__getRootTerms **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRootTerms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllTermsFromOntologyResponse(struct soap *soap, _ns1__getAllTermsFromOntologyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllTermsFromOntologyResponse(struct soap *soap, const char *tag, int id, _ns1__getAllTermsFromOntologyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntologyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllTermsFromOntologyResponse(struct soap *soap, const char *tag, _ns1__getAllTermsFromOntologyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllTermsFromOntologyResponse **)soap_malloc(soap, sizeof(_ns1__getAllTermsFromOntologyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllTermsFromOntologyResponse *)soap_instantiate__ns1__getAllTermsFromOntologyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllTermsFromOntologyResponse ** p = (_ns1__getAllTermsFromOntologyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllTermsFromOntologyResponse, sizeof(_ns1__getAllTermsFromOntologyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllTermsFromOntologyResponse(struct soap *soap, _ns1__getAllTermsFromOntologyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntologyResponse);
	if (soap_out_PointerTo_ns1__getAllTermsFromOntologyResponse(soap, tag?tag:"ns1:getAllTermsFromOntologyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntologyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllTermsFromOntologyResponse(struct soap *soap, _ns1__getAllTermsFromOntologyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllTermsFromOntologyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllTermsFromOntology(struct soap *soap, _ns1__getAllTermsFromOntology *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllTermsFromOntology))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllTermsFromOntology(struct soap *soap, const char *tag, int id, _ns1__getAllTermsFromOntology *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllTermsFromOntology);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntology ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllTermsFromOntology(struct soap *soap, const char *tag, _ns1__getAllTermsFromOntology **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAllTermsFromOntology **)soap_malloc(soap, sizeof(_ns1__getAllTermsFromOntology *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAllTermsFromOntology *)soap_instantiate__ns1__getAllTermsFromOntology(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAllTermsFromOntology ** p = (_ns1__getAllTermsFromOntology **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllTermsFromOntology, sizeof(_ns1__getAllTermsFromOntology), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllTermsFromOntology(struct soap *soap, _ns1__getAllTermsFromOntology *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllTermsFromOntology);
	if (soap_out_PointerTo_ns1__getAllTermsFromOntology(soap, tag?tag:"ns1:getAllTermsFromOntology", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAllTermsFromOntology ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllTermsFromOntology(struct soap *soap, _ns1__getAllTermsFromOntology **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllTermsFromOntology(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOntologyLoadDateResponse(struct soap *soap, _ns1__getOntologyLoadDateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOntologyLoadDateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOntologyLoadDateResponse(struct soap *soap, const char *tag, int id, _ns1__getOntologyLoadDateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOntologyLoadDateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getOntologyLoadDateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOntologyLoadDateResponse(struct soap *soap, const char *tag, _ns1__getOntologyLoadDateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getOntologyLoadDateResponse **)soap_malloc(soap, sizeof(_ns1__getOntologyLoadDateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getOntologyLoadDateResponse *)soap_instantiate__ns1__getOntologyLoadDateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getOntologyLoadDateResponse ** p = (_ns1__getOntologyLoadDateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOntologyLoadDateResponse, sizeof(_ns1__getOntologyLoadDateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOntologyLoadDateResponse(struct soap *soap, _ns1__getOntologyLoadDateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOntologyLoadDateResponse);
	if (soap_out_PointerTo_ns1__getOntologyLoadDateResponse(soap, tag?tag:"ns1:getOntologyLoadDateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getOntologyLoadDateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOntologyLoadDateResponse(struct soap *soap, _ns1__getOntologyLoadDateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOntologyLoadDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOntologyLoadDate(struct soap *soap, _ns1__getOntologyLoadDate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOntologyLoadDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOntologyLoadDate(struct soap *soap, const char *tag, int id, _ns1__getOntologyLoadDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOntologyLoadDate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getOntologyLoadDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOntologyLoadDate(struct soap *soap, const char *tag, _ns1__getOntologyLoadDate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getOntologyLoadDate **)soap_malloc(soap, sizeof(_ns1__getOntologyLoadDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getOntologyLoadDate *)soap_instantiate__ns1__getOntologyLoadDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getOntologyLoadDate ** p = (_ns1__getOntologyLoadDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOntologyLoadDate, sizeof(_ns1__getOntologyLoadDate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOntologyLoadDate(struct soap *soap, _ns1__getOntologyLoadDate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOntologyLoadDate);
	if (soap_out_PointerTo_ns1__getOntologyLoadDate(soap, tag?tag:"ns1:getOntologyLoadDate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getOntologyLoadDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOntologyLoadDate(struct soap *soap, _ns1__getOntologyLoadDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOntologyLoadDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOntologyNamesResponse(struct soap *soap, _ns1__getOntologyNamesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOntologyNamesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOntologyNamesResponse(struct soap *soap, const char *tag, int id, _ns1__getOntologyNamesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOntologyNamesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getOntologyNamesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOntologyNamesResponse(struct soap *soap, const char *tag, _ns1__getOntologyNamesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getOntologyNamesResponse **)soap_malloc(soap, sizeof(_ns1__getOntologyNamesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getOntologyNamesResponse *)soap_instantiate__ns1__getOntologyNamesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getOntologyNamesResponse ** p = (_ns1__getOntologyNamesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOntologyNamesResponse, sizeof(_ns1__getOntologyNamesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOntologyNamesResponse(struct soap *soap, _ns1__getOntologyNamesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOntologyNamesResponse);
	if (soap_out_PointerTo_ns1__getOntologyNamesResponse(soap, tag?tag:"ns1:getOntologyNamesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getOntologyNamesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOntologyNamesResponse(struct soap *soap, _ns1__getOntologyNamesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOntologyNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOntologyNames(struct soap *soap, _ns1__getOntologyNames *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOntologyNames))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOntologyNames(struct soap *soap, const char *tag, int id, _ns1__getOntologyNames *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOntologyNames);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getOntologyNames ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOntologyNames(struct soap *soap, const char *tag, _ns1__getOntologyNames **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getOntologyNames **)soap_malloc(soap, sizeof(_ns1__getOntologyNames *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getOntologyNames *)soap_instantiate__ns1__getOntologyNames(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getOntologyNames ** p = (_ns1__getOntologyNames **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOntologyNames, sizeof(_ns1__getOntologyNames), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOntologyNames(struct soap *soap, _ns1__getOntologyNames *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOntologyNames);
	if (soap_out_PointerTo_ns1__getOntologyNames(soap, tag?tag:"ns1:getOntologyNames", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getOntologyNames ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOntologyNames(struct soap *soap, _ns1__getOntologyNames **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOntologyNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermXrefsResponse(struct soap *soap, _ns1__getTermXrefsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermXrefsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermXrefsResponse(struct soap *soap, const char *tag, int id, _ns1__getTermXrefsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermXrefsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermXrefsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermXrefsResponse(struct soap *soap, const char *tag, _ns1__getTermXrefsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermXrefsResponse **)soap_malloc(soap, sizeof(_ns1__getTermXrefsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermXrefsResponse *)soap_instantiate__ns1__getTermXrefsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermXrefsResponse ** p = (_ns1__getTermXrefsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermXrefsResponse, sizeof(_ns1__getTermXrefsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermXrefsResponse(struct soap *soap, _ns1__getTermXrefsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermXrefsResponse);
	if (soap_out_PointerTo_ns1__getTermXrefsResponse(soap, tag?tag:"ns1:getTermXrefsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermXrefsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermXrefsResponse(struct soap *soap, _ns1__getTermXrefsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermXrefsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermXrefs(struct soap *soap, _ns1__getTermXrefs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermXrefs))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermXrefs(struct soap *soap, const char *tag, int id, _ns1__getTermXrefs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermXrefs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermXrefs ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermXrefs(struct soap *soap, const char *tag, _ns1__getTermXrefs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermXrefs **)soap_malloc(soap, sizeof(_ns1__getTermXrefs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermXrefs *)soap_instantiate__ns1__getTermXrefs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermXrefs ** p = (_ns1__getTermXrefs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermXrefs, sizeof(_ns1__getTermXrefs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermXrefs(struct soap *soap, _ns1__getTermXrefs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermXrefs);
	if (soap_out_PointerTo_ns1__getTermXrefs(soap, tag?tag:"ns1:getTermXrefs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermXrefs ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermXrefs(struct soap *soap, _ns1__getTermXrefs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermXrefs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermMetadataResponse(struct soap *soap, _ns1__getTermMetadataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermMetadataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermMetadataResponse(struct soap *soap, const char *tag, int id, _ns1__getTermMetadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermMetadataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermMetadataResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermMetadataResponse(struct soap *soap, const char *tag, _ns1__getTermMetadataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermMetadataResponse **)soap_malloc(soap, sizeof(_ns1__getTermMetadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermMetadataResponse *)soap_instantiate__ns1__getTermMetadataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermMetadataResponse ** p = (_ns1__getTermMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermMetadataResponse, sizeof(_ns1__getTermMetadataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermMetadataResponse(struct soap *soap, _ns1__getTermMetadataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermMetadataResponse);
	if (soap_out_PointerTo_ns1__getTermMetadataResponse(soap, tag?tag:"ns1:getTermMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermMetadataResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermMetadataResponse(struct soap *soap, _ns1__getTermMetadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermMetadata(struct soap *soap, _ns1__getTermMetadata *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermMetadata))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermMetadata(struct soap *soap, const char *tag, int id, _ns1__getTermMetadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermMetadata);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermMetadata ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermMetadata(struct soap *soap, const char *tag, _ns1__getTermMetadata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermMetadata **)soap_malloc(soap, sizeof(_ns1__getTermMetadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermMetadata *)soap_instantiate__ns1__getTermMetadata(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermMetadata ** p = (_ns1__getTermMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermMetadata, sizeof(_ns1__getTermMetadata), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermMetadata(struct soap *soap, _ns1__getTermMetadata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermMetadata);
	if (soap_out_PointerTo_ns1__getTermMetadata(soap, tag?tag:"ns1:getTermMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermMetadata ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermMetadata(struct soap *soap, _ns1__getTermMetadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermByIdResponse(struct soap *soap, _ns1__getTermByIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermByIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermByIdResponse(struct soap *soap, const char *tag, int id, _ns1__getTermByIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermByIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermByIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermByIdResponse(struct soap *soap, const char *tag, _ns1__getTermByIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermByIdResponse **)soap_malloc(soap, sizeof(_ns1__getTermByIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermByIdResponse *)soap_instantiate__ns1__getTermByIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermByIdResponse ** p = (_ns1__getTermByIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermByIdResponse, sizeof(_ns1__getTermByIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermByIdResponse(struct soap *soap, _ns1__getTermByIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermByIdResponse);
	if (soap_out_PointerTo_ns1__getTermByIdResponse(soap, tag?tag:"ns1:getTermByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermByIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermByIdResponse(struct soap *soap, _ns1__getTermByIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTermById(struct soap *soap, _ns1__getTermById *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTermById))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTermById(struct soap *soap, const char *tag, int id, _ns1__getTermById *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTermById);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTermById ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTermById(struct soap *soap, const char *tag, _ns1__getTermById **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTermById **)soap_malloc(soap, sizeof(_ns1__getTermById *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTermById *)soap_instantiate__ns1__getTermById(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTermById ** p = (_ns1__getTermById **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTermById, sizeof(_ns1__getTermById), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTermById(struct soap *soap, _ns1__getTermById *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTermById);
	if (soap_out_PointerTo_ns1__getTermById(soap, tag?tag:"ns1:getTermById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTermById ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTermById(struct soap *soap, _ns1__getTermById **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTermById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVersionResponse(struct soap *soap, _ns1__getVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVersionResponse(struct soap *soap, const char *tag, int id, _ns1__getVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVersionResponse(struct soap *soap, const char *tag, _ns1__getVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getVersionResponse **)soap_malloc(soap, sizeof(_ns1__getVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getVersionResponse *)soap_instantiate__ns1__getVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getVersionResponse ** p = (_ns1__getVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVersionResponse, sizeof(_ns1__getVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVersionResponse(struct soap *soap, _ns1__getVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVersionResponse);
	if (soap_out_PointerTo_ns1__getVersionResponse(soap, tag?tag:"ns1:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVersionResponse(struct soap *soap, _ns1__getVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVersion(struct soap *soap, _ns1__getVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVersion(struct soap *soap, const char *tag, int id, _ns1__getVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getVersion ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVersion(struct soap *soap, const char *tag, _ns1__getVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getVersion **)soap_malloc(soap, sizeof(_ns1__getVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getVersion *)soap_instantiate__ns1__getVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getVersion ** p = (_ns1__getVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVersion, sizeof(_ns1__getVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVersion(struct soap *soap, _ns1__getVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVersion);
	if (soap_out_PointerTo_ns1__getVersion(soap, tag?tag:"ns1:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getVersion ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVersion(struct soap *soap, _ns1__getVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__mapItem(struct soap *soap, ns2__mapItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__mapItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__mapItem(struct soap *soap, const char *tag, int id, ns2__mapItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__mapItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__mapItem ** SOAP_FMAC4 soap_in_PointerTons2__mapItem(struct soap *soap, const char *tag, ns2__mapItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__mapItem **)soap_malloc(soap, sizeof(ns2__mapItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__mapItem *)soap_instantiate_ns2__mapItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__mapItem ** p = (ns2__mapItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__mapItem, sizeof(ns2__mapItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__mapItem(struct soap *soap, ns2__mapItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__mapItem);
	if (soap_out_PointerTons2__mapItem(soap, tag?tag:"ns2:mapItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__mapItem ** SOAP_FMAC4 soap_get_PointerTons2__mapItem(struct soap *soap, ns2__mapItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__mapItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__double, sizeof(xsd__double), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__int, sizeof(xsd__int), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__mapItem, sizeof(ns2__mapItem), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Map, sizeof(ns2__Map), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Vector, sizeof(ns2__Vector), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__DataHolder, sizeof(ns3__DataHolder), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DataHolder(struct soap *soap, ns3__DataHolder *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__DataHolder))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DataHolder(struct soap *soap, const char *tag, int id, ns3__DataHolder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__DataHolder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__DataHolder ** SOAP_FMAC4 soap_in_PointerTons3__DataHolder(struct soap *soap, const char *tag, ns3__DataHolder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DataHolder **)soap_malloc(soap, sizeof(ns3__DataHolder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DataHolder *)soap_instantiate_ns3__DataHolder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__DataHolder ** p = (ns3__DataHolder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__DataHolder, sizeof(ns3__DataHolder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DataHolder(struct soap *soap, ns3__DataHolder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__DataHolder);
	if (soap_out_PointerTons3__DataHolder(soap, tag?tag:"ns3:DataHolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DataHolder ** SOAP_FMAC4 soap_get_PointerTons3__DataHolder(struct soap *soap, ns3__DataHolder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DataHolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Vector(struct soap *soap, ns2__Vector *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Vector))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Vector(struct soap *soap, const char *tag, int id, ns2__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Vector);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Vector ** SOAP_FMAC4 soap_in_PointerTons2__Vector(struct soap *soap, const char *tag, ns2__Vector **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Vector **)soap_malloc(soap, sizeof(ns2__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Vector *)soap_instantiate_ns2__Vector(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Vector ** p = (ns2__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Vector, sizeof(ns2__Vector), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Vector(struct soap *soap, ns2__Vector *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Vector);
	if (soap_out_PointerTons2__Vector(soap, tag?tag:"ns2:Vector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Vector ** SOAP_FMAC4 soap_get_PointerTons2__Vector(struct soap *soap, ns2__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Map(struct soap *soap, ns2__Map *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Map))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Map(struct soap *soap, const char *tag, int id, ns2__Map *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Map);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Map ** SOAP_FMAC4 soap_in_PointerTons2__Map(struct soap *soap, const char *tag, ns2__Map **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Map **)soap_malloc(soap, sizeof(ns2__Map *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Map *)soap_instantiate_ns2__Map(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Map ** p = (ns2__Map **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Map, sizeof(ns2__Map), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Map(struct soap *soap, ns2__Map *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Map);
	if (soap_out_PointerTons2__Map(soap, tag?tag:"ns2:Map", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Map ** SOAP_FMAC4 soap_get_PointerTons2__Map(struct soap *soap, ns2__Map **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, std::vector<xsd__anyType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const std::vector<xsd__anyType * >*a)
{
	for (std::vector<xsd__anyType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToxsd__anyType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const char *tag, int id, const std::vector<xsd__anyType * >*a, const char *type)
{
	for (std::vector<xsd__anyType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToxsd__anyType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xsd__anyType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const char *tag, std::vector<xsd__anyType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToxsd__anyType(soap, -1)))
		return NULL;
	xsd__anyType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__anyType, SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType, sizeof(xsd__anyType), 1))
				break;
			if (!soap_in_PointerToxsd__anyType(soap, tag, NULL, "xsd:anyType"))
				break;
		}
		else
		{
			if (!soap_in_PointerToxsd__anyType(soap, tag, &n, "xsd:anyType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xsd__anyType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToxsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__anyType * >);
		if (size)
			*size = sizeof(std::vector<xsd__anyType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__anyType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<xsd__anyType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<xsd__anyType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<xsd__anyType * > %p -> %p\n", q, p));
	*(std::vector<xsd__anyType * >*)p = *(std::vector<xsd__anyType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__mapItem(struct soap *soap, std::vector<ns2__mapItem * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__mapItem(struct soap *soap, const std::vector<ns2__mapItem * >*a)
{
	for (std::vector<ns2__mapItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__mapItem(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__mapItem(struct soap *soap, const char *tag, int id, const std::vector<ns2__mapItem * >*a, const char *type)
{
	for (std::vector<ns2__mapItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__mapItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__mapItem * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__mapItem(struct soap *soap, const char *tag, std::vector<ns2__mapItem * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__mapItem(soap, -1)))
		return NULL;
	ns2__mapItem *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__mapItem, SOAP_TYPE_std__vectorTemplateOfPointerTons2__mapItem, sizeof(ns2__mapItem), 1))
				break;
			if (!soap_in_PointerTons2__mapItem(soap, tag, NULL, "ns2:mapItem"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__mapItem(soap, tag, &n, "ns2:mapItem"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__mapItem * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__mapItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__mapItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__mapItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__mapItem * >);
		if (size)
			*size = sizeof(std::vector<ns2__mapItem * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__mapItem * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__mapItem * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__mapItem * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__mapItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__mapItem * > %p -> %p\n", q, p));
	*(std::vector<ns2__mapItem * >*)p = *(std::vector<ns2__mapItem * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__DataHolder(struct soap *soap, std::vector<ns3__DataHolder * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__DataHolder(struct soap *soap, const std::vector<ns3__DataHolder * >*a)
{
	for (std::vector<ns3__DataHolder * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__DataHolder(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__DataHolder(struct soap *soap, const char *tag, int id, const std::vector<ns3__DataHolder * >*a, const char *type)
{
	for (std::vector<ns3__DataHolder * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__DataHolder(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__DataHolder * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__DataHolder(struct soap *soap, const char *tag, std::vector<ns3__DataHolder * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__DataHolder(soap, -1)))
		return NULL;
	ns3__DataHolder *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__DataHolder, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DataHolder, sizeof(ns3__DataHolder), 1))
				break;
			if (!soap_in_PointerTons3__DataHolder(soap, tag, NULL, "ns3:DataHolder"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__DataHolder(soap, tag, &n, "ns3:DataHolder"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__DataHolder * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__DataHolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__DataHolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__DataHolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__DataHolder * >);
		if (size)
			*size = sizeof(std::vector<ns3__DataHolder * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__DataHolder * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__DataHolder * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__DataHolder * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__DataHolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__DataHolder * > %p -> %p\n", q, p));
	*(std::vector<ns3__DataHolder * >*)p = *(std::vector<ns3__DataHolder * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >);
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
