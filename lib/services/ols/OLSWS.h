/* 
   Generated by wsdl2h 2.8.4 from http://www.ebi.ac.uk/ontology-lookup/OntologyQuery.wsdl and typemap.dat
   2011-11-24 18:00:35 GMT

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS
   USE THE soapcpp2-GENERATED SOURCE CODE FILES FOR YOUR PROJECT BUILDS

   gSOAP XML Web services tools.
   Copyright (C) 2001-2010 Robert van Engelen, Genivia Inc. All Rights Reserved.
   Part of this software is released under one of the following licenses:
   GPL or Genivia's license for commercial use.
*/

/** @page page_notes Usage Notes

NOTE:

 - Run soapcpp2 on this file to generate the SOAP/XML processing logic.
   Use soapcpp2 option -I to specify paths for #import
   To build with STL, 'stlvector.h' is imported from 'import' dir in package.
   Use soapcpp2 option -i to generate improved proxy and server classes.
 - Use wsdl2h options -c and -s to generate pure C code or C++ code without STL.
 - Use 'typemap.dat' to control namespace bindings and type mappings.
   It is strongly recommended to customize the names of the namespace prefixes
   generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
   section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
 - Use Doxygen (www.doxygen.org) on this file to generate documentation.
 - Use wsdl2h options -nname and -Nname to globally rename the prefix 'ns'.
 - Use wsdl2h option -d to enable DOM support for xsd:anyType.
 - Use wsdl2h option -g to auto-generate readers and writers for root elements.
 - Struct/class members serialized as XML attributes are annotated with a '@'.
 - Struct/class members that have a special role are annotated with a '$'.

WARNING:

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS.
   USE THE SOURCE CODE FILES GENERATED BY soapcpp2 FOR YOUR PROJECT BUILDS:
   THE soapStub.h FILE CONTAINS THIS CONTENT WITHOUT ANNOTATIONS.

LICENSE:

@verbatim
--------------------------------------------------------------------------------
gSOAP XML Web services tools
Copyright (C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.

This software is released under one of the following two licenses:
1) GPL or 2) Genivia's license for commercial use.
--------------------------------------------------------------------------------
1) GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org

This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
2) A commercial-use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
@endverbatim

*/


//gsoapopt w

/******************************************************************************\
 *                                                                            *
 * Definitions                                                                *
 *   http://www.ebi.ac.uk/ontology-lookup/OntologyQuery                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Import                                                                     *
 *                                                                            *
\******************************************************************************/


// STL vector containers (use option -s to remove STL dependency)
#import "stlvector.h"

/******************************************************************************\
 *                                                                            *
 * Schema Namespaces                                                          *
 *                                                                            *
\******************************************************************************/


/* NOTE:

It is strongly recommended to customize the names of the namespace prefixes
generated by wsdl2h. To do so, modify the prefix bindings below and add the
modified lines to typemap.dat to rerun wsdl2h:

ns1 = "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery"
ns2 = "http://xml.apache.org/xml-soap"
ns3 = "http://model.web.ook.ebi.ac.uk"

*/

#define SOAP_NAMESPACE_OF_ns1	"http://www.ebi.ac.uk/ontology-lookup/OntologyQuery"
//gsoap ns1   schema namespace:	http://www.ebi.ac.uk/ontology-lookup/OntologyQuery
//gsoap ns1   schema elementForm:	qualified
//gsoap ns1   schema attributeForm:	unqualified

#define SOAP_NAMESPACE_OF_ns2	"http://xml.apache.org/xml-soap"
//gsoap ns2   schema namespace:	http://xml.apache.org/xml-soap
//gsoap ns2   schema elementForm:	qualified
//gsoap ns2   schema attributeForm:	unqualified

#define SOAP_NAMESPACE_OF_ns3	"http://model.web.ook.ebi.ac.uk"
//gsoap ns3   schema namespace:	http://model.web.ook.ebi.ac.uk
//gsoap ns3   schema elementForm:	qualified
//gsoap ns3   schema attributeForm:	unqualified
class xsd__anyType { _XML __item; struct soap *soap; };

/******************************************************************************\
 *                                                                            *
 * Built-in Schema Types and Top-Level Elements and Attributes                *
 *                                                                            *
\******************************************************************************/


/// Class wrapper for built-in type "xs:boolean" derived from xsd__anyType
/// Use soap_type() == SOAP_TYPE_xsd__boolean to check runtime type (see soapStub.h)
class xsd__boolean : public xsd__anyType
{ public:
    bool                                 __item;                       
};

/// Class wrapper for built-in type "xs:double" derived from xsd__anyType
/// Use soap_type() == SOAP_TYPE_xsd__double to check runtime type (see soapStub.h)
class xsd__double : public xsd__anyType
{ public:
    double                               __item;                       
};

/// Class wrapper for built-in type "xs:int" derived from xsd__anyType
/// Use soap_type() == SOAP_TYPE_xsd__int to check runtime type (see soapStub.h)
class xsd__int : public xsd__anyType
{ public:
    int                                  __item;                       
};

/// Class wrapper for built-in type "xs:string" derived from xsd__anyType
/// Use soap_type() == SOAP_TYPE_xsd__string to check runtime type (see soapStub.h)
class xsd__string : public xsd__anyType
{ public:
    std::string                          __item;                       
};

/******************************************************************************\
 *                                                                            *
 * Forward Declarations                                                       *
 *                                                                            *
\******************************************************************************/



//  Forward declaration of class _ns1__getVersion.
class _ns1__getVersion;

//  Forward declaration of class _ns1__getVersionResponse.
class _ns1__getVersionResponse;

//  Forward declaration of class _ns1__getTermById.
class _ns1__getTermById;

//  Forward declaration of class _ns1__getTermByIdResponse.
class _ns1__getTermByIdResponse;

//  Forward declaration of class _ns1__getTermMetadata.
class _ns1__getTermMetadata;

//  Forward declaration of class _ns1__getTermMetadataResponse.
class _ns1__getTermMetadataResponse;

//  Forward declaration of class _ns1__getTermXrefs.
class _ns1__getTermXrefs;

//  Forward declaration of class _ns1__getTermXrefsResponse.
class _ns1__getTermXrefsResponse;

//  Forward declaration of class _ns1__getOntologyNames.
class _ns1__getOntologyNames;

//  Forward declaration of class _ns1__getOntologyNamesResponse.
class _ns1__getOntologyNamesResponse;

//  Forward declaration of class _ns1__getOntologyLoadDate.
class _ns1__getOntologyLoadDate;

//  Forward declaration of class _ns1__getOntologyLoadDateResponse.
class _ns1__getOntologyLoadDateResponse;

//  Forward declaration of class _ns1__getAllTermsFromOntology.
class _ns1__getAllTermsFromOntology;

//  Forward declaration of class _ns1__getAllTermsFromOntologyResponse.
class _ns1__getAllTermsFromOntologyResponse;

//  Forward declaration of class _ns1__getRootTerms.
class _ns1__getRootTerms;

//  Forward declaration of class _ns1__getRootTermsResponse.
class _ns1__getRootTermsResponse;

//  Forward declaration of class _ns1__getTermsByName.
class _ns1__getTermsByName;

//  Forward declaration of class _ns1__getTermsByNameResponse.
class _ns1__getTermsByNameResponse;

//  Forward declaration of class _ns1__getTermsByExactName.
class _ns1__getTermsByExactName;

//  Forward declaration of class _ns1__getTermsByExactNameResponse.
class _ns1__getTermsByExactNameResponse;

//  Forward declaration of class _ns1__getPrefixedTermsByName.
class _ns1__getPrefixedTermsByName;

//  Forward declaration of class _ns1__getPrefixedTermsByNameResponse.
class _ns1__getPrefixedTermsByNameResponse;

//  Forward declaration of class _ns1__getTermParents.
class _ns1__getTermParents;

//  Forward declaration of class _ns1__getTermParentsResponse.
class _ns1__getTermParentsResponse;

//  Forward declaration of class _ns1__getTermChildren.
class _ns1__getTermChildren;

//  Forward declaration of class _ns1__getTermChildrenResponse.
class _ns1__getTermChildrenResponse;

//  Forward declaration of class _ns1__getTermRelations.
class _ns1__getTermRelations;

//  Forward declaration of class _ns1__getTermRelationsResponse.
class _ns1__getTermRelationsResponse;

//  Forward declaration of class _ns1__getChildrenFromRoot.
class _ns1__getChildrenFromRoot;

//  Forward declaration of class _ns1__getChildrenFromRootResponse.
class _ns1__getChildrenFromRootResponse;

//  Forward declaration of class _ns1__isObsolete.
class _ns1__isObsolete;

//  Forward declaration of class _ns1__isObsoleteResponse.
class _ns1__isObsoleteResponse;

//  Forward declaration of class _ns1__getTermsByAnnotationData.
class _ns1__getTermsByAnnotationData;

//  Forward declaration of class _ns1__getTermsByAnnotationDataResponse.
class _ns1__getTermsByAnnotationDataResponse;

//  Forward declaration of class ns2__mapItem.
class ns2__mapItem;

//  Forward declaration of class ns2__Map.
class ns2__Map;

//  Forward declaration of class ns2__Vector.
class ns2__Vector;

//  Forward declaration of class ns3__DataHolder.
class ns3__DataHolder;

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://www.ebi.ac.uk/ontology-lookup/OntologyQuery                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xml.apache.org/xml-soap                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://model.web.ook.ebi.ac.uk                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://www.ebi.ac.uk/ontology-lookup/OntologyQuery                       *
 *                                                                            *
\******************************************************************************/



/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getVersion

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getVersion is a complexType.
class _ns1__getVersion
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getVersionResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getVersionResponse is a complexType.
class _ns1__getVersionResponse
{ public:
/// Element getVersionReturn of type xs:string.
    std::string                          getVersionReturn               1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermById

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermById is a complexType.
class _ns1__getTermById
{ public:
/// Element termId of type xs:string.
    std::string                          termId                         1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermByIdResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermByIdResponse is a complexType.
class _ns1__getTermByIdResponse
{ public:
/// Element getTermByIdReturn of type xs:string.
    std::string                          getTermByIdReturn              1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermMetadata

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermMetadata is a complexType.
class _ns1__getTermMetadata
{ public:
/// Element termId of type xs:string.
    std::string                          termId                         1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermMetadataResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermMetadataResponse is a complexType.
class _ns1__getTermMetadataResponse
{ public:
/// Element getTermMetadataReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getTermMetadataReturn          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermXrefs

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermXrefs is a complexType.
class _ns1__getTermXrefs
{ public:
/// Element termId of type xs:string.
    std::string                          termId                         1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermXrefsResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermXrefsResponse is a complexType.
class _ns1__getTermXrefsResponse
{ public:
/// Element getTermXrefsReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getTermXrefsReturn             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyNames

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyNames is a complexType.
class _ns1__getOntologyNames
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyNamesResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyNamesResponse is a complexType.
class _ns1__getOntologyNamesResponse
{ public:
/// Element getOntologyNamesReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getOntologyNamesReturn         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyLoadDate

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyLoadDate is a complexType.
class _ns1__getOntologyLoadDate
{ public:
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyLoadDateResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getOntologyLoadDateResponse is a complexType.
class _ns1__getOntologyLoadDateResponse
{ public:
/// Element getOntologyLoadDateReturn of type xs:string.
    std::string                          getOntologyLoadDateReturn      1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getAllTermsFromOntology

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getAllTermsFromOntology is a complexType.
class _ns1__getAllTermsFromOntology
{ public:
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getAllTermsFromOntologyResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getAllTermsFromOntologyResponse is a complexType.
class _ns1__getAllTermsFromOntologyResponse
{ public:
/// Element getAllTermsFromOntologyReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getAllTermsFromOntologyReturn  1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getRootTerms

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getRootTerms is a complexType.
class _ns1__getRootTerms
{ public:
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getRootTermsResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getRootTermsResponse is a complexType.
class _ns1__getRootTermsResponse
{ public:
/// Element getRootTermsReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getRootTermsReturn             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByName

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByName is a complexType.
class _ns1__getTermsByName
{ public:
/// Element partialName of type xs:string.
    std::string                          partialName                    1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// Element reverseKeyOrder of type xs:boolean.
    bool                                 reverseKeyOrder                1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByNameResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByNameResponse is a complexType.
class _ns1__getTermsByNameResponse
{ public:
/// Element getTermsByNameReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getTermsByNameReturn           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByExactName

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByExactName is a complexType.
class _ns1__getTermsByExactName
{ public:
/// Element exactName of type xs:string.
    std::string                          exactName                      1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByExactNameResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByExactNameResponse is a complexType.
class _ns1__getTermsByExactNameResponse
{ public:
/// Element getTermsByExactNameReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getTermsByExactNameReturn      1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getPrefixedTermsByName

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getPrefixedTermsByName is a complexType.
class _ns1__getPrefixedTermsByName
{ public:
/// Element partialName of type xs:string.
    std::string                          partialName                    1;	///< Required element.
/// Element reverseKeyOrder of type xs:boolean.
    bool                                 reverseKeyOrder                1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getPrefixedTermsByNameResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getPrefixedTermsByNameResponse is a complexType.
class _ns1__getPrefixedTermsByNameResponse
{ public:
/// Element getPrefixedTermsByNameReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getPrefixedTermsByNameReturn   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermParents

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermParents is a complexType.
class _ns1__getTermParents
{ public:
/// Element termId of type xs:string.
    std::string                          termId                         1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermParentsResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermParentsResponse is a complexType.
class _ns1__getTermParentsResponse
{ public:
/// Element getTermParentsReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getTermParentsReturn           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermChildren

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermChildren is a complexType.
class _ns1__getTermChildren
{ public:
/// Element termId of type xs:string.
    std::string                          termId                         1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// Element distance of type xs:int.
    int                                  distance                       1;	///< Required element.
/// Vector of int with length 1..unbounded
    std::vector<int                    > relationTypes                  1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermChildrenResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermChildrenResponse is a complexType.
class _ns1__getTermChildrenResponse
{ public:
/// Element getTermChildrenReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getTermChildrenReturn          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermRelations

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermRelations is a complexType.
class _ns1__getTermRelations
{ public:
/// Element termId of type xs:string.
    std::string                          termId                         1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermRelationsResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermRelationsResponse is a complexType.
class _ns1__getTermRelationsResponse
{ public:
/// Element getTermRelationsReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getTermRelationsReturn         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getChildrenFromRoot

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getChildrenFromRoot is a complexType.
class _ns1__getChildrenFromRoot
{ public:
/// Element rootTermId of type xs:string.
    std::string                          rootTermId                     1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// Element childrenIds of type "http://xml.apache.org/xml-soap":Vector.
    ns2__Vector*                         childrenIds                    1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getChildrenFromRootResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getChildrenFromRootResponse is a complexType.
class _ns1__getChildrenFromRootResponse
{ public:
/// Element getChildrenFromRootReturn of type "http://xml.apache.org/xml-soap":Map.
    ns2__Map*                            getChildrenFromRootReturn      1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":isObsolete

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":isObsolete is a complexType.
class _ns1__isObsolete
{ public:
/// Element termId of type xs:string.
    std::string                          termId                         1;	///< Required element.
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":isObsoleteResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":isObsoleteResponse is a complexType.
class _ns1__isObsoleteResponse
{ public:
/// Element isObsoleteReturn of type xs:boolean.
    bool                                 isObsoleteReturn               1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByAnnotationData

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByAnnotationData is a complexType.
class _ns1__getTermsByAnnotationData
{ public:
/// Element ontologyName of type xs:string.
    std::string                          ontologyName                   1;	///< Required element.
/// Element annotationType of type xs:string.
    std::string                          annotationType                 1;	///< Required element.
/// Element strValue of type xs:string.
    std::string                          strValue                       1;	///< Required element.
/// Element fromDblValue of type xs:double.
    double                               fromDblValue                   1;	///< Required element.
/// Element toDblValue of type xs:double.
    double                               toDblValue                     1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByAnnotationDataResponse

/// "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery":getTermsByAnnotationDataResponse is a complexType.
class _ns1__getTermsByAnnotationDataResponse
{ public:
/// Vector of ns3__DataHolder* with length 1..unbounded
    std::vector<ns3__DataHolder*       > getTermsByAnnotationDataReturn 1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xml.apache.org/xml-soap                                           *
 *                                                                            *
\******************************************************************************/


/// "http://xml.apache.org/xml-soap":mapItem is a complexType.
class ns2__mapItem : public xsd__anyType
{ public:
/// Element key of type xs:anyType.
    xsd__anyType*                        key                           ;	///< Nullable pointer.
/// Element value of type xs:anyType.
    xsd__anyType*                        value                         ;	///< Nullable pointer.
};

/// "http://xml.apache.org/xml-soap":Map is a complexType.
class ns2__Map : public xsd__anyType
{ public:
/// Vector of ns2__mapItem* with length 0..unbounded
    std::vector<ns2__mapItem*          > item                           0;
};

/// "http://xml.apache.org/xml-soap":Vector is a complexType.
class ns2__Vector : public xsd__anyType
{ public:
/// Vector of xsd__anyType* with length 0..unbounded
    std::vector<xsd__anyType*          > item                           0;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://model.web.ook.ebi.ac.uk                                           *
 *                                                                            *
\******************************************************************************/


/// "http://model.web.ook.ebi.ac.uk":DataHolder is a complexType.
class ns3__DataHolder : public xsd__anyType
{ public:
/// Element annotationNumberValue of type xs:double.
    double*                              annotationNumberValue         ;	///< Nullable pointer.
/// Element annotationStringValue of type xs:string.
    std::string*                         annotationStringValue         ;	///< Nullable pointer.
/// Element annotationType of type xs:string.
    std::string*                         annotationType                ;	///< Nullable pointer.
/// Element termId of type xs:string.
    std::string*                         termId                        ;	///< Nullable pointer.
/// Element termName of type xs:string.
    std::string*                         termName                      ;	///< Nullable pointer.
};

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://www.ebi.ac.uk/ontology-lookup/OntologyQuery                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://www.ebi.ac.uk/ontology-lookup/OntologyQuery                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xml.apache.org/xml-soap                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xml.apache.org/xml-soap                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://model.web.ook.ebi.ac.uk                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://model.web.ook.ebi.ac.uk                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Services                                                                   *
 *                                                                            *
\******************************************************************************/


//gsoap ns1  service name:	OntologyQuerySoapBinding 
//gsoap ns1  service type:	Query 
//gsoap ns1  service port:	http://www.ebi.ac.uk/ontology-lookup/services/OntologyQuery 
//gsoap ns1  service namespace:	http://www.ebi.ac.uk/ontology-lookup/OntologyQuery 
//gsoap ns1  service transport:	http://schemas.xmlsoap.org/soap/http 

/** @mainpage Service Definitions

@section Service_bindings Service Bindings

  - @ref OntologyQuerySoapBinding

@section Service_more More Information

  - @ref page_notes "Usage Notes"

  - @ref page_XMLDataBinding "XML Data Binding"

  - @ref SOAP_ENV__Header "SOAP Header Content" (when applicable)

  - @ref SOAP_ENV__Detail "SOAP Fault Detail Content" (when applicable)


*/

/**

@page OntologyQuerySoapBinding Binding "OntologyQuerySoapBinding"

@section OntologyQuerySoapBinding_operations Operations of Binding  "OntologyQuerySoapBinding"

  - @ref __ns1__getVersion

  - @ref __ns1__getTermById

  - @ref __ns1__getTermMetadata

  - @ref __ns1__getTermXrefs

  - @ref __ns1__getOntologyNames

  - @ref __ns1__getOntologyLoadDate

  - @ref __ns1__getAllTermsFromOntology

  - @ref __ns1__getRootTerms

  - @ref __ns1__getTermsByName

  - @ref __ns1__getTermsByExactName

  - @ref __ns1__getPrefixedTermsByName

  - @ref __ns1__getTermParents

  - @ref __ns1__getTermChildren

  - @ref __ns1__getTermRelations

  - @ref __ns1__getChildrenFromRoot

  - @ref __ns1__isObsolete

  - @ref __ns1__getTermsByAnnotationData

@section OntologyQuerySoapBinding_ports Endpoints of Binding  "OntologyQuerySoapBinding"

  - http://www.ebi.ac.uk/ontology-lookup/services/OntologyQuery

Note: use wsdl2h option -N to change the service binding prefix name

*/

/******************************************************************************\
 *                                                                            *
 * Service Binding                                                            *
 *   OntologyQuerySoapBinding                                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getVersion                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getVersion" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getVersion"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getVersionRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getVersionResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getVersion(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getVersion*                   ns1__getVersion,
    // response parameters:
    _ns1__getVersionResponse*           ns1__getVersionResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getVersion(
    struct soap *soap,
    // request parameters:
    _ns1__getVersion*                   ns1__getVersion,
    // response parameters:
    _ns1__getVersionResponse*           ns1__getVersionResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getVersion document
//gsoap ns1  service method-encoding:	getVersion literal
//gsoap ns1  service method-action:	getVersion getVersion
//gsoap ns1  service method-output-action:	getVersion http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getVersionResponse
int __ns1__getVersion(
    _ns1__getVersion*                   ns1__getVersion,	///< Request parameter
    _ns1__getVersionResponse*           ns1__getVersionResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermById                                                       *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermById" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermById"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermByIdRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermByIdResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermById(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermById*                  ns1__getTermById,
    // response parameters:
    _ns1__getTermByIdResponse*          ns1__getTermByIdResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermById(
    struct soap *soap,
    // request parameters:
    _ns1__getTermById*                  ns1__getTermById,
    // response parameters:
    _ns1__getTermByIdResponse*          ns1__getTermByIdResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermById document
//gsoap ns1  service method-encoding:	getTermById literal
//gsoap ns1  service method-action:	getTermById getTermById
//gsoap ns1  service method-output-action:	getTermById http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermByIdResponse
int __ns1__getTermById(
    _ns1__getTermById*                  ns1__getTermById,	///< Request parameter
    _ns1__getTermByIdResponse*          ns1__getTermByIdResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermMetadata                                                   *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermMetadata" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermMetadata"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermMetadataRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermMetadataResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermMetadata(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermMetadata*              ns1__getTermMetadata,
    // response parameters:
    _ns1__getTermMetadataResponse*      ns1__getTermMetadataResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermMetadata(
    struct soap *soap,
    // request parameters:
    _ns1__getTermMetadata*              ns1__getTermMetadata,
    // response parameters:
    _ns1__getTermMetadataResponse*      ns1__getTermMetadataResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermMetadata document
//gsoap ns1  service method-encoding:	getTermMetadata literal
//gsoap ns1  service method-action:	getTermMetadata getTermMetadata
//gsoap ns1  service method-output-action:	getTermMetadata http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermMetadataResponse
int __ns1__getTermMetadata(
    _ns1__getTermMetadata*              ns1__getTermMetadata,	///< Request parameter
    _ns1__getTermMetadataResponse*      ns1__getTermMetadataResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermXrefs                                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermXrefs" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermXrefs"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermXrefsRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermXrefsResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermXrefs(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermXrefs*                 ns1__getTermXrefs,
    // response parameters:
    _ns1__getTermXrefsResponse*         ns1__getTermXrefsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermXrefs(
    struct soap *soap,
    // request parameters:
    _ns1__getTermXrefs*                 ns1__getTermXrefs,
    // response parameters:
    _ns1__getTermXrefsResponse*         ns1__getTermXrefsResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermXrefs document
//gsoap ns1  service method-encoding:	getTermXrefs literal
//gsoap ns1  service method-action:	getTermXrefs getTermXrefs
//gsoap ns1  service method-output-action:	getTermXrefs http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermXrefsResponse
int __ns1__getTermXrefs(
    _ns1__getTermXrefs*                 ns1__getTermXrefs,	///< Request parameter
    _ns1__getTermXrefsResponse*         ns1__getTermXrefsResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getOntologyNames                                                  *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getOntologyNames" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getOntologyNames"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getOntologyNamesRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getOntologyNamesResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getOntologyNames(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getOntologyNames*             ns1__getOntologyNames,
    // response parameters:
    _ns1__getOntologyNamesResponse*     ns1__getOntologyNamesResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getOntologyNames(
    struct soap *soap,
    // request parameters:
    _ns1__getOntologyNames*             ns1__getOntologyNames,
    // response parameters:
    _ns1__getOntologyNamesResponse*     ns1__getOntologyNamesResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getOntologyNames document
//gsoap ns1  service method-encoding:	getOntologyNames literal
//gsoap ns1  service method-action:	getOntologyNames getOntologyNames
//gsoap ns1  service method-output-action:	getOntologyNames http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getOntologyNamesResponse
int __ns1__getOntologyNames(
    _ns1__getOntologyNames*             ns1__getOntologyNames,	///< Request parameter
    _ns1__getOntologyNamesResponse*     ns1__getOntologyNamesResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getOntologyLoadDate                                               *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getOntologyLoadDate" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getOntologyLoadDate"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getOntologyLoadDateRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getOntologyLoadDateResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getOntologyLoadDate(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getOntologyLoadDate*          ns1__getOntologyLoadDate,
    // response parameters:
    _ns1__getOntologyLoadDateResponse*  ns1__getOntologyLoadDateResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getOntologyLoadDate(
    struct soap *soap,
    // request parameters:
    _ns1__getOntologyLoadDate*          ns1__getOntologyLoadDate,
    // response parameters:
    _ns1__getOntologyLoadDateResponse*  ns1__getOntologyLoadDateResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getOntologyLoadDate document
//gsoap ns1  service method-encoding:	getOntologyLoadDate literal
//gsoap ns1  service method-action:	getOntologyLoadDate getOntologyLoadDate
//gsoap ns1  service method-output-action:	getOntologyLoadDate http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getOntologyLoadDateResponse
int __ns1__getOntologyLoadDate(
    _ns1__getOntologyLoadDate*          ns1__getOntologyLoadDate,	///< Request parameter
    _ns1__getOntologyLoadDateResponse*  ns1__getOntologyLoadDateResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getAllTermsFromOntology                                           *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getAllTermsFromOntology" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getAllTermsFromOntology"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getAllTermsFromOntologyRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getAllTermsFromOntologyResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getAllTermsFromOntology(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getAllTermsFromOntology*      ns1__getAllTermsFromOntology,
    // response parameters:
    _ns1__getAllTermsFromOntologyResponse* ns1__getAllTermsFromOntologyResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getAllTermsFromOntology(
    struct soap *soap,
    // request parameters:
    _ns1__getAllTermsFromOntology*      ns1__getAllTermsFromOntology,
    // response parameters:
    _ns1__getAllTermsFromOntologyResponse* ns1__getAllTermsFromOntologyResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getAllTermsFromOntology document
//gsoap ns1  service method-encoding:	getAllTermsFromOntology literal
//gsoap ns1  service method-action:	getAllTermsFromOntology getAllTermsFromOntology
//gsoap ns1  service method-output-action:	getAllTermsFromOntology http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getAllTermsFromOntologyResponse
int __ns1__getAllTermsFromOntology(
    _ns1__getAllTermsFromOntology*      ns1__getAllTermsFromOntology,	///< Request parameter
    _ns1__getAllTermsFromOntologyResponse* ns1__getAllTermsFromOntologyResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getRootTerms                                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getRootTerms" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getRootTerms"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getRootTermsRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getRootTermsResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getRootTerms(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getRootTerms*                 ns1__getRootTerms,
    // response parameters:
    _ns1__getRootTermsResponse*         ns1__getRootTermsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getRootTerms(
    struct soap *soap,
    // request parameters:
    _ns1__getRootTerms*                 ns1__getRootTerms,
    // response parameters:
    _ns1__getRootTermsResponse*         ns1__getRootTermsResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getRootTerms document
//gsoap ns1  service method-encoding:	getRootTerms literal
//gsoap ns1  service method-action:	getRootTerms getRootTerms
//gsoap ns1  service method-output-action:	getRootTerms http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getRootTermsResponse
int __ns1__getRootTerms(
    _ns1__getRootTerms*                 ns1__getRootTerms,	///< Request parameter
    _ns1__getRootTermsResponse*         ns1__getRootTermsResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermsByName                                                    *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermsByName" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermsByName"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByNameRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByNameResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermsByName(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermsByName*               ns1__getTermsByName,
    // response parameters:
    _ns1__getTermsByNameResponse*       ns1__getTermsByNameResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermsByName(
    struct soap *soap,
    // request parameters:
    _ns1__getTermsByName*               ns1__getTermsByName,
    // response parameters:
    _ns1__getTermsByNameResponse*       ns1__getTermsByNameResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermsByName document
//gsoap ns1  service method-encoding:	getTermsByName literal
//gsoap ns1  service method-action:	getTermsByName getTermsByName
//gsoap ns1  service method-output-action:	getTermsByName http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByNameResponse
int __ns1__getTermsByName(
    _ns1__getTermsByName*               ns1__getTermsByName,	///< Request parameter
    _ns1__getTermsByNameResponse*       ns1__getTermsByNameResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermsByExactName                                               *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermsByExactName" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermsByExactName"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByExactNameRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByExactNameResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermsByExactName(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermsByExactName*          ns1__getTermsByExactName,
    // response parameters:
    _ns1__getTermsByExactNameResponse*  ns1__getTermsByExactNameResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermsByExactName(
    struct soap *soap,
    // request parameters:
    _ns1__getTermsByExactName*          ns1__getTermsByExactName,
    // response parameters:
    _ns1__getTermsByExactNameResponse*  ns1__getTermsByExactNameResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermsByExactName document
//gsoap ns1  service method-encoding:	getTermsByExactName literal
//gsoap ns1  service method-action:	getTermsByExactName getTermsByExactName
//gsoap ns1  service method-output-action:	getTermsByExactName http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByExactNameResponse
int __ns1__getTermsByExactName(
    _ns1__getTermsByExactName*          ns1__getTermsByExactName,	///< Request parameter
    _ns1__getTermsByExactNameResponse*  ns1__getTermsByExactNameResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getPrefixedTermsByName                                            *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getPrefixedTermsByName" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getPrefixedTermsByName"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getPrefixedTermsByNameRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getPrefixedTermsByNameResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getPrefixedTermsByName(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getPrefixedTermsByName*       ns1__getPrefixedTermsByName,
    // response parameters:
    _ns1__getPrefixedTermsByNameResponse* ns1__getPrefixedTermsByNameResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getPrefixedTermsByName(
    struct soap *soap,
    // request parameters:
    _ns1__getPrefixedTermsByName*       ns1__getPrefixedTermsByName,
    // response parameters:
    _ns1__getPrefixedTermsByNameResponse* ns1__getPrefixedTermsByNameResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getPrefixedTermsByName document
//gsoap ns1  service method-encoding:	getPrefixedTermsByName literal
//gsoap ns1  service method-action:	getPrefixedTermsByName getPrefixedTermsByName
//gsoap ns1  service method-output-action:	getPrefixedTermsByName http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getPrefixedTermsByNameResponse
int __ns1__getPrefixedTermsByName(
    _ns1__getPrefixedTermsByName*       ns1__getPrefixedTermsByName,	///< Request parameter
    _ns1__getPrefixedTermsByNameResponse* ns1__getPrefixedTermsByNameResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermParents                                                    *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermParents" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermParents"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermParentsRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermParentsResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermParents(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermParents*               ns1__getTermParents,
    // response parameters:
    _ns1__getTermParentsResponse*       ns1__getTermParentsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermParents(
    struct soap *soap,
    // request parameters:
    _ns1__getTermParents*               ns1__getTermParents,
    // response parameters:
    _ns1__getTermParentsResponse*       ns1__getTermParentsResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermParents document
//gsoap ns1  service method-encoding:	getTermParents literal
//gsoap ns1  service method-action:	getTermParents getTermParents
//gsoap ns1  service method-output-action:	getTermParents http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermParentsResponse
int __ns1__getTermParents(
    _ns1__getTermParents*               ns1__getTermParents,	///< Request parameter
    _ns1__getTermParentsResponse*       ns1__getTermParentsResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermChildren                                                   *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermChildren" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermChildren"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermChildrenRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermChildrenResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermChildren(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermChildren*              ns1__getTermChildren,
    // response parameters:
    _ns1__getTermChildrenResponse*      ns1__getTermChildrenResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermChildren(
    struct soap *soap,
    // request parameters:
    _ns1__getTermChildren*              ns1__getTermChildren,
    // response parameters:
    _ns1__getTermChildrenResponse*      ns1__getTermChildrenResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermChildren document
//gsoap ns1  service method-encoding:	getTermChildren literal
//gsoap ns1  service method-action:	getTermChildren getTermChildren
//gsoap ns1  service method-output-action:	getTermChildren http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermChildrenResponse
int __ns1__getTermChildren(
    _ns1__getTermChildren*              ns1__getTermChildren,	///< Request parameter
    _ns1__getTermChildrenResponse*      ns1__getTermChildrenResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermRelations                                                  *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermRelations" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermRelations"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermRelationsRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermRelationsResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermRelations(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermRelations*             ns1__getTermRelations,
    // response parameters:
    _ns1__getTermRelationsResponse*     ns1__getTermRelationsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermRelations(
    struct soap *soap,
    // request parameters:
    _ns1__getTermRelations*             ns1__getTermRelations,
    // response parameters:
    _ns1__getTermRelationsResponse*     ns1__getTermRelationsResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermRelations document
//gsoap ns1  service method-encoding:	getTermRelations literal
//gsoap ns1  service method-action:	getTermRelations getTermRelations
//gsoap ns1  service method-output-action:	getTermRelations http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermRelationsResponse
int __ns1__getTermRelations(
    _ns1__getTermRelations*             ns1__getTermRelations,	///< Request parameter
    _ns1__getTermRelationsResponse*     ns1__getTermRelationsResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getChildrenFromRoot                                               *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getChildrenFromRoot" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getChildrenFromRoot"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getChildrenFromRootRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getChildrenFromRootResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getChildrenFromRoot(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getChildrenFromRoot*          ns1__getChildrenFromRoot,
    // response parameters:
    _ns1__getChildrenFromRootResponse*  ns1__getChildrenFromRootResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getChildrenFromRoot(
    struct soap *soap,
    // request parameters:
    _ns1__getChildrenFromRoot*          ns1__getChildrenFromRoot,
    // response parameters:
    _ns1__getChildrenFromRootResponse*  ns1__getChildrenFromRootResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getChildrenFromRoot document
//gsoap ns1  service method-encoding:	getChildrenFromRoot literal
//gsoap ns1  service method-action:	getChildrenFromRoot getChildrenFromRoot
//gsoap ns1  service method-output-action:	getChildrenFromRoot http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getChildrenFromRootResponse
int __ns1__getChildrenFromRoot(
    _ns1__getChildrenFromRoot*          ns1__getChildrenFromRoot,	///< Request parameter
    _ns1__getChildrenFromRootResponse*  ns1__getChildrenFromRootResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__isObsolete                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__isObsolete" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "isObsolete"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/isObsoleteRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/isObsoleteResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__isObsolete(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__isObsolete*                   ns1__isObsolete,
    // response parameters:
    _ns1__isObsoleteResponse*           ns1__isObsoleteResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__isObsolete(
    struct soap *soap,
    // request parameters:
    _ns1__isObsolete*                   ns1__isObsolete,
    // response parameters:
    _ns1__isObsoleteResponse*           ns1__isObsoleteResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	isObsolete document
//gsoap ns1  service method-encoding:	isObsolete literal
//gsoap ns1  service method-action:	isObsolete isObsolete
//gsoap ns1  service method-output-action:	isObsolete http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/isObsoleteResponse
int __ns1__isObsolete(
    _ns1__isObsolete*                   ns1__isObsolete,	///< Request parameter
    _ns1__isObsoleteResponse*           ns1__isObsoleteResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns1__getTermsByAnnotationData                                          *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns1__getTermsByAnnotationData" of service binding "OntologyQuerySoapBinding"

/**

Operation details:


  - SOAP document/literal style messaging

  - SOAP action: "getTermsByAnnotationData"

  - Addressing action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByAnnotationDataRequest"

  - Addressing response action: "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByAnnotationDataResponse"

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns1__getTermsByAnnotationData(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns1__getTermsByAnnotationData*     ns1__getTermsByAnnotationData,
    // response parameters:
    _ns1__getTermsByAnnotationDataResponse* ns1__getTermsByAnnotationDataResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns1__getTermsByAnnotationData(
    struct soap *soap,
    // request parameters:
    _ns1__getTermsByAnnotationData*     ns1__getTermsByAnnotationData,
    // response parameters:
    _ns1__getTermsByAnnotationDataResponse* ns1__getTermsByAnnotationDataResponse
  );
@endcode

C++ proxy class (defined in soapOntologyQuerySoapBindingProxy.h):
@code
  class OntologyQuerySoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapOntologyQuerySoapBindingService.h):
@code
  class OntologyQuerySoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns1  service method-style:	getTermsByAnnotationData document
//gsoap ns1  service method-encoding:	getTermsByAnnotationData literal
//gsoap ns1  service method-action:	getTermsByAnnotationData getTermsByAnnotationData
//gsoap ns1  service method-output-action:	getTermsByAnnotationData http://www.ebi.ac.uk/ontology-lookup/OntologyQuery/Query/getTermsByAnnotationDataResponse
int __ns1__getTermsByAnnotationData(
    _ns1__getTermsByAnnotationData*     ns1__getTermsByAnnotationData,	///< Request parameter
    _ns1__getTermsByAnnotationDataResponse* ns1__getTermsByAnnotationDataResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * XML Data Binding                                                           *
 *                                                                            *
\******************************************************************************/


/**

@page page_XMLDataBinding XML Data Binding

SOAP/XML services use data bindings contractually bound by WSDL and auto-
generated by wsdl2h and soapcpp2 (see Service Bindings). Plain data bindings
are adopted from XML schemas as part of the WSDL types section or when running
wsdl2h on a set of schemas to produce non-SOAP-based XML data bindings.

The following readers and writers are C/C++ data type (de)serializers auto-
generated by wsdl2h and soapcpp2. Run soapcpp2 on this file to generate the
(de)serialization code, which is stored in soapC.c[pp]. Include "soapH.h" in
your code to import these data type and function declarations. Only use the
soapcpp2-generated files in your project build. Do not include the wsdl2h-
generated .h file in your code.

XML content can be retrieved from:
  - a file descriptor, using soap->recvfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->is = ...
  - a buffer, using the soap->frecv() callback

XML content can be stored to:
  - a file descriptor, using soap->sendfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->os = ...
  - a buffer, using the soap->fsend() callback


@section ns1 Top-level root elements of schema "http://www.ebi.ac.uk/ontology-lookup/OntologyQuery"

  - <ns1:getVersion> @ref _ns1__getVersion
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getVersion(struct soap*, _ns1__getVersion*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getVersion(struct soap*, _ns1__getVersion*);
    @endcode

  - <ns1:getVersionResponse> @ref _ns1__getVersionResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getVersionResponse(struct soap*, _ns1__getVersionResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getVersionResponse(struct soap*, _ns1__getVersionResponse*);
    @endcode

  - <ns1:getTermById> @ref _ns1__getTermById
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermById(struct soap*, _ns1__getTermById*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermById(struct soap*, _ns1__getTermById*);
    @endcode

  - <ns1:getTermByIdResponse> @ref _ns1__getTermByIdResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermByIdResponse(struct soap*, _ns1__getTermByIdResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermByIdResponse(struct soap*, _ns1__getTermByIdResponse*);
    @endcode

  - <ns1:getTermMetadata> @ref _ns1__getTermMetadata
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermMetadata(struct soap*, _ns1__getTermMetadata*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermMetadata(struct soap*, _ns1__getTermMetadata*);
    @endcode

  - <ns1:getTermMetadataResponse> @ref _ns1__getTermMetadataResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermMetadataResponse(struct soap*, _ns1__getTermMetadataResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermMetadataResponse(struct soap*, _ns1__getTermMetadataResponse*);
    @endcode

  - <ns1:getTermXrefs> @ref _ns1__getTermXrefs
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermXrefs(struct soap*, _ns1__getTermXrefs*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermXrefs(struct soap*, _ns1__getTermXrefs*);
    @endcode

  - <ns1:getTermXrefsResponse> @ref _ns1__getTermXrefsResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermXrefsResponse(struct soap*, _ns1__getTermXrefsResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermXrefsResponse(struct soap*, _ns1__getTermXrefsResponse*);
    @endcode

  - <ns1:getOntologyNames> @ref _ns1__getOntologyNames
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getOntologyNames(struct soap*, _ns1__getOntologyNames*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getOntologyNames(struct soap*, _ns1__getOntologyNames*);
    @endcode

  - <ns1:getOntologyNamesResponse> @ref _ns1__getOntologyNamesResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getOntologyNamesResponse(struct soap*, _ns1__getOntologyNamesResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getOntologyNamesResponse(struct soap*, _ns1__getOntologyNamesResponse*);
    @endcode

  - <ns1:getOntologyLoadDate> @ref _ns1__getOntologyLoadDate
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getOntologyLoadDate(struct soap*, _ns1__getOntologyLoadDate*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getOntologyLoadDate(struct soap*, _ns1__getOntologyLoadDate*);
    @endcode

  - <ns1:getOntologyLoadDateResponse> @ref _ns1__getOntologyLoadDateResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getOntologyLoadDateResponse(struct soap*, _ns1__getOntologyLoadDateResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getOntologyLoadDateResponse(struct soap*, _ns1__getOntologyLoadDateResponse*);
    @endcode

  - <ns1:getAllTermsFromOntology> @ref _ns1__getAllTermsFromOntology
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getAllTermsFromOntology(struct soap*, _ns1__getAllTermsFromOntology*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getAllTermsFromOntology(struct soap*, _ns1__getAllTermsFromOntology*);
    @endcode

  - <ns1:getAllTermsFromOntologyResponse> @ref _ns1__getAllTermsFromOntologyResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getAllTermsFromOntologyResponse(struct soap*, _ns1__getAllTermsFromOntologyResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getAllTermsFromOntologyResponse(struct soap*, _ns1__getAllTermsFromOntologyResponse*);
    @endcode

  - <ns1:getRootTerms> @ref _ns1__getRootTerms
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getRootTerms(struct soap*, _ns1__getRootTerms*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getRootTerms(struct soap*, _ns1__getRootTerms*);
    @endcode

  - <ns1:getRootTermsResponse> @ref _ns1__getRootTermsResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getRootTermsResponse(struct soap*, _ns1__getRootTermsResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getRootTermsResponse(struct soap*, _ns1__getRootTermsResponse*);
    @endcode

  - <ns1:getTermsByName> @ref _ns1__getTermsByName
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermsByName(struct soap*, _ns1__getTermsByName*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermsByName(struct soap*, _ns1__getTermsByName*);
    @endcode

  - <ns1:getTermsByNameResponse> @ref _ns1__getTermsByNameResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermsByNameResponse(struct soap*, _ns1__getTermsByNameResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermsByNameResponse(struct soap*, _ns1__getTermsByNameResponse*);
    @endcode

  - <ns1:getTermsByExactName> @ref _ns1__getTermsByExactName
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermsByExactName(struct soap*, _ns1__getTermsByExactName*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermsByExactName(struct soap*, _ns1__getTermsByExactName*);
    @endcode

  - <ns1:getTermsByExactNameResponse> @ref _ns1__getTermsByExactNameResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermsByExactNameResponse(struct soap*, _ns1__getTermsByExactNameResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermsByExactNameResponse(struct soap*, _ns1__getTermsByExactNameResponse*);
    @endcode

  - <ns1:getPrefixedTermsByName> @ref _ns1__getPrefixedTermsByName
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getPrefixedTermsByName(struct soap*, _ns1__getPrefixedTermsByName*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getPrefixedTermsByName(struct soap*, _ns1__getPrefixedTermsByName*);
    @endcode

  - <ns1:getPrefixedTermsByNameResponse> @ref _ns1__getPrefixedTermsByNameResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getPrefixedTermsByNameResponse(struct soap*, _ns1__getPrefixedTermsByNameResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getPrefixedTermsByNameResponse(struct soap*, _ns1__getPrefixedTermsByNameResponse*);
    @endcode

  - <ns1:getTermParents> @ref _ns1__getTermParents
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermParents(struct soap*, _ns1__getTermParents*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermParents(struct soap*, _ns1__getTermParents*);
    @endcode

  - <ns1:getTermParentsResponse> @ref _ns1__getTermParentsResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermParentsResponse(struct soap*, _ns1__getTermParentsResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermParentsResponse(struct soap*, _ns1__getTermParentsResponse*);
    @endcode

  - <ns1:getTermChildren> @ref _ns1__getTermChildren
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermChildren(struct soap*, _ns1__getTermChildren*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermChildren(struct soap*, _ns1__getTermChildren*);
    @endcode

  - <ns1:getTermChildrenResponse> @ref _ns1__getTermChildrenResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermChildrenResponse(struct soap*, _ns1__getTermChildrenResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermChildrenResponse(struct soap*, _ns1__getTermChildrenResponse*);
    @endcode

  - <ns1:getTermRelations> @ref _ns1__getTermRelations
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermRelations(struct soap*, _ns1__getTermRelations*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermRelations(struct soap*, _ns1__getTermRelations*);
    @endcode

  - <ns1:getTermRelationsResponse> @ref _ns1__getTermRelationsResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermRelationsResponse(struct soap*, _ns1__getTermRelationsResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermRelationsResponse(struct soap*, _ns1__getTermRelationsResponse*);
    @endcode

  - <ns1:getChildrenFromRoot> @ref _ns1__getChildrenFromRoot
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getChildrenFromRoot(struct soap*, _ns1__getChildrenFromRoot*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getChildrenFromRoot(struct soap*, _ns1__getChildrenFromRoot*);
    @endcode

  - <ns1:getChildrenFromRootResponse> @ref _ns1__getChildrenFromRootResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getChildrenFromRootResponse(struct soap*, _ns1__getChildrenFromRootResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getChildrenFromRootResponse(struct soap*, _ns1__getChildrenFromRootResponse*);
    @endcode

  - <ns1:isObsolete> @ref _ns1__isObsolete
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__isObsolete(struct soap*, _ns1__isObsolete*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__isObsolete(struct soap*, _ns1__isObsolete*);
    @endcode

  - <ns1:isObsoleteResponse> @ref _ns1__isObsoleteResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__isObsoleteResponse(struct soap*, _ns1__isObsoleteResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__isObsoleteResponse(struct soap*, _ns1__isObsoleteResponse*);
    @endcode

  - <ns1:getTermsByAnnotationData> @ref _ns1__getTermsByAnnotationData
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermsByAnnotationData(struct soap*, _ns1__getTermsByAnnotationData*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermsByAnnotationData(struct soap*, _ns1__getTermsByAnnotationData*);
    @endcode

  - <ns1:getTermsByAnnotationDataResponse> @ref _ns1__getTermsByAnnotationDataResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns1__getTermsByAnnotationDataResponse(struct soap*, _ns1__getTermsByAnnotationDataResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns1__getTermsByAnnotationDataResponse(struct soap*, _ns1__getTermsByAnnotationDataResponse*);
    @endcode

@section ns2 Top-level root elements of schema "http://xml.apache.org/xml-soap"

@section ns3 Top-level root elements of schema "http://model.web.ook.ebi.ac.uk"

*/

/* End of file */
